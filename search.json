[{"title":"Android开发——Android Studio IDE 的配置与安装","url":"/2019/08/04/Android%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94Android%20Studio%20IDE%20%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%89%E8%A3%85/","content":"Android Studio IDE 的配置与安装\n\n下载、安装 Android Studio IDE官网下载 Android StudioAndroid Studio 官网下载\n配置SDK出于代码通用性和平台统一性的考虑，SDK版本一律使用最新的稳定版\n目前版本为 Android Pie（API 28）\n设置 gradlegradle 是一个自动化构建工具，在语法上是基于Groovy语言的（Groovy 是一种基于JVM的敏捷开发语言，可以简单的理解为强类型语言java的弱类型版本），在项目管理上是基于Ant和Maven概念的项目自动化建构工具。\nAndroid Gradle 入门 | 飞雪无情的博客\n一般来说，国内无法直接下载 gradle 包，解决方法有三：\n\n设置代理（翻墙）在 Android Studio 中设置 Proxy\n\n使用国内镜像站下载 gradle 包修改build.gradle文件\nbuildscript &#123;    repositories &#123;        maven &#123; url &#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27; &#125;        maven&#123; url &#x27;http://maven.aliyun.com/nexus/content/repositories/jcenter&#x27;&#125;    &#125;    dependencies &#123;        classpath &#x27;com.android.tools.build:gradle:2.2.3&#x27;        // NOTE: Do not place your application dependencies here; they belong        // in the individual module build.gradle files    &#125;&#125;allprojects &#123;    repositories &#123;        maven &#123; url &#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27; &#125;        maven&#123; url &#x27;http://maven.aliyun.com/nexus/content/repositories/jcenter&#x27;&#125;    &#125;&#125;\n使用本地 gradle\n\n\n没有翻墙条件的最佳解决方案：\n\n新建工程、修改build.gradle\ngradle 构建完成后，修改方式为使用本地 gradle 包\n\n使用 AVD 虚拟设备打开 AVD Manager， 新建虚拟设备，选择与测试机相匹配的配置：\n\n尺寸\n分辨率\n屏幕密度*\nAPI镜像版本\n\n出现 HAXM 或 VT-X 错误，原因是需要主板开启虚拟设备加速（VT-x），需要进入 BIOS 中设置。\n进入方式可以搜索自己的笔记本型号，查询进入 BIOS 的方式。\n利用 adb 进行调试ADB：Android Debug Bridge  \n常用命令：\n\n\n\nadb命令\n含义\n*参数1\n*参数2\n\n\n\nstart-server\n启动连接\n\n\n\n\nkill-server\n断开连接\n\n\n\n\ninstall\n安装apk包\n*.apk\n\n\n\nuninstall\n卸载某程序\n程序包名(com.xxx[公司名].xxx[项目名])\n\n\n\npush\n上传文件\n待推送(push)文件\n目标（设备）路径\n\n\npull\n下载文件\n待取回(pull)文件\n目标（本地）路径\n\n\nshell\n进入设备终端\n\n\n\n\n进入设备终端后的命令（Linux命令）：\n\n\n\nLinux命令\n含义\n参数1\n*参数2\n\n\n\nrm\nremove|删除\n某文件路径\n\n\n\nls\nlist|列表\n\n\n\n\nmv\nmove|移动（重命名）\n原文件\n新文件\n\n\ncd\nchange directory|切换目录\n路径\n\n\n\ncp\ncopy|复制\n源文件\n目标路径\n\n\npm\n包管理\n\n\n\n\n\n\n\npm指令\n\n\n\n\n\n\ninstall\n安装apk包\n*.apk\nP版本(9.0)只允许安装/data/local/tmp/下的apk包\n\n\n\n-r\n\n强制替换原包（升级更新）\n\n\nuninstall\n卸载包\n包名\n\n\n\nlist packages\n列出所有安装包\n\n\n\n\n\n-3\n\n列出所有第三方安装包\n\n\n\n","categories":["实习"],"tags":["Android","Android开发"]},{"title":"Android开发——Http网络编程","url":"/2019/08/07/Android%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94Http%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","content":"Http网络编程GET、POST、Upload、Download\n\n\nHttp(s)协议简介简介  HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本–HTTP 1.1。  HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示（如文本先于图形）等。  HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型，而且HTTP是一个无状态的协议。\n主要特点\n简单快速：客户向服务器请求服务时，只需传达请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户端与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。\n\n灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。\n\n无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。采用这种方式可以节省传输时间。\n\n无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大；另一方面，在服务器不需要先前信息时，它的应答就很快。\n\n支持B/S及C/S模式\n\n\nHTTP协议请求消息结构  客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。\n\nHTTP消息体主要包含以下实质内容（空格和换行也必不可少）：\n\n请求方法\nURL：统一资源定位符\nHTTP请求头部\nHTTP请求体\n\n\n请求方法\n\n\n序号\n方法\n描述\n\n\n\n1\nGET\n请求指定的页面信息，并返回实体主体\n\n\n2\nHEAD\n类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头\n\n\n3\nPOST\n向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立或已有资源的修改\n\n\n4\nPUT\n从客户端向服务器传送的数据取代指定的文档的内容\n\n\n5\nDELETE\n请求服务器删除指定的页面\n\n\n6\nCONNECT\nHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n\n\n7\nOPTIONS\n允许客户端查看服务器的性能\n\n\n8\nTRACE\n回显服务器收到的请求，主要用于测试或诊断。\n\n\nHTTP响应HTTP的响应同样分为：响应行、响应头和响应体。\n\n状态码  HTTP的状态码由三位数字组成，第一个数字定义了响应的类别，共有5种类别：\n\n1xx：指示信息 — 表示请求已接收，继续处理\n2xx：成功 — 表示请求已被成功接收、理解、接受\n3xx：重定向 — 要完成请求必须进行更进一步的操作\n4xx：客户端错误 — 请求有语法错误或请求无法实现\n5xx：服务器端错误 — 服务器未能实现合法的请求\n\n常见的状态码\n200 OK：客户端请求成功\n400 Bad Request：客户端请求有语法错误，不能被服务器所理解\n401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用\n403 Forbidden：服务器收到请求，但是拒绝提供服务\n404 Not Found：请求资源不存在，不如：输入了错误的URL\n500 Internal Server Error：服务器发生不可预期的错误\n503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。\n更多状态码见：HTTP响应码大全\n\n\n参考：HTTP协议详解|幸运四叶草\n\nGET 请求和 POST 请求的区别区别\nGET请求：请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分隔URL和传输数据，多个参数用&amp;进行连接；如果数据是英文字母/数组，原样发送，如果是空格，则转换为+，如果是中文/其他字符，则直接把字符串用base64进行加密。\nPOST请求：把提交的数据放置在是HTTP包的包体中。因此，GET请求的数据会在地址栏中显示出来；而POST请求，地址栏不会改变。\n\n实际开发中传输大小存在的限制\nGET：特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节（2K + 35）。对于其他浏览器，如FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。因此对于GET请求时，传输数据就会受到URL长度的限制。\nPOST：由于不是通过URL传值，理论上数据不受限制。但实际各个web服务器会规定对POST请求数据大小进行限制，Apache、IIS6都有各自的配置。\n\n安全性  POST的安全性要比GET的安全性高。比如：GET提交数据，用户名和密码将以明文的形式出现在URL上，因为①登录页面有可能被浏览器缓存；②其他人查看浏览器的历史记录；除此之外，使用GET提交数据还可能会造成 Cross-site request forgery 攻击。\nAndroid 原生Http方法访问网络使用流程start=&gt;start: 注明权限，并且在子线程中执行网络操作op1=&gt;operation: 建立 URL 对象op2=&gt;operation: 创建 Http(s)URLConnection 对象op3=&gt;operation: 对 Connection 对象设置各种属性op4=&gt;condition: 获得 ResponseCode ResponseCode == 200？op5=&gt;operation: 获得返回的文件流 (InputStream)OK=&gt;end: 成功ERROR=&gt;end: 失败start-&gt;op1-&gt;op2-&gt;op3-&gt;op4op4(yes)-&gt;op5-&gt;OKop4(no)-&gt;ERROR\n\n在 Manifest 中写明权限&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;\n\n新建子线程在子线程中运行网络下载服务\nnew Thread(new Runnable() &#123;    @Override    public void run() &#123;        //\tTODO:Download files from server.    &#125;&#125;).start();\n\n建立URL对象URL url = new URL(&quot;https://valpha.xyz/testserver/noByBy.mp3&quot;);//\t传入的类型为String的URL链接\n\n建立 Http(s)URLConnection 对象HttpsURLConnection conn = (HttpsUrlConnection) url.openConnection();HttpURLConnection conn = (HttpUrlConnection) url.openConnection();//\thttp与https协议的类是不同的，需要分别使用\n\n\n\n在Android 9.0中（API 28），系统默认不支持非HTTPS的协议，想要使用不安全的HTTP协议需要在Manifest中设置\n&lt;application\tandroid:usesCleartextTraffic=&quot;true&quot;\t...&lt;/application&gt;\n\n\n\n设置 Connection 参数属性（即 Request 的属性）//\t设置使用&quot;GET&quot;请求conn.setRequestMethod(&quot;GET&quot;);//\t设置超时时间为5000msconn.setReadTimeout(5000);//\t设置请求附加属性(key,value)connection.setRequestProperty(&quot;username&quot;,&quot;zhangsan&quot;);connection.setRequestProperty(&quot;password&quot;,&quot;123456&quot;);\n\n获得 ResponseCode（即发送请求）int code = connection.getResponseCode();if (200 == code)&#123;    //\tTODO: Anything you want to do like download files    saveFileToLocal(connection.getInputStream());&#125; else &#123;    //\tWrong code. Request failed. &#125;\n\n从网络流中下载文件private void saveFileToLocal(InputStream in) throws IOException &#123;    //\t实例化一个文件对象    File file = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS), &quot;file.name&quot;);    //\t打开写入文件的流    FileOutputStream fileOutputStream = new FileOutputStream(file);    //\t当前获取到的长度    int length = 0;    //\t缓存区大小    byte[] buffer = new byte[1024];    //\t从网络流中读取数据流至缓存区，length为实际读取到的长度    while((length = in.read(buffer, 0, 1024)) &gt; 0) &#123;        //\t将缓存区中的数据流写入本地文件        //\t重要！此处必须设定长度为读取到的实际长度        //\t否则会写入非常多的空区域        fileOutputStream.write(buffer, 0, length);    &#125;    //\t本地文件写入完毕后需要关闭本地文件流（真正写入本地文件）    fileOutputStream.close();&#125;\n\n\n\n在将数据从缓存写入本地文件中时，必须指定写入长度，不然会默认写入全部缓冲区大小，而缓冲区大小固定长度为1024，会导致文件错误！\nfileOutputStream.write(buffer, 0, length);\n\n\n\n总结 使用官方的 HttpURLConnection 较为繁琐，需要先新建 URL 对象，然后通过 URL 实例打开 Connection ，再对 Connection 设置Request属性，再获取RequestCode和RequestBody，然后通过流处理，将网络数据流写入本地文件。\nCoding 时需要保持逻辑清晰，条理清楚，不然很容易写错。接下来介绍使用开源框架访问 Http 的方法。\n使用开源框架访问 HTTP开源框架——OkHttpOkHttp 是一个优秀的网络请求框架，不仅可以手动创建子线程发送同步请求，也可以自动发送异步请求。通过构建者模式生成统一的请求对象，不用区分Http还是Https，效率高且方便快捷。\nokhttp | Github.com\n安装在build.gradle中写入依赖\nimplementation(&quot;com.squareup.okhttp3:okhttp:3.4.1&quot;)\n\n使用start=&gt;start: 创建 OkHttpClient 对象end=&gt;end: 成功op1=&gt;operation: 利用 Request.Builder() 创建一个 Request 对象op2=&gt;operation: 使用 Client 调用 newCall(Request) 方法返回一个 Response 对象op3=&gt;operation: 对 Response 对象进行操作start-&gt;op1-&gt;op2-&gt;op3-&gt;end\n\n创建 OkHttpClient 对象OkHttpClient client = new OkHttpClient();\n\n或\nOkHttpClient client = new OkHttpClient.Builder()    .connectTimeout(5, TimeUnit.SECONDS)    .build();\n\n\n\n创建 Request 对象\n 构造者模式：将需要构建的属性通过.XXX(“XXX”)设置，最后.build()生成 Request 对象\n\n\nGET 方法\n\nRequest request = new Request.Builder()    .url(&quot;https://valpha.xyz/testserver/loginget.php?username=zhangsan&amp;password=123456&quot;)    .build();\n\n\nPOST 方法\n\nRequestBody requestBody = new FormBody.Builder()        .add(&quot;username&quot;, &quot;zhangsan&quot;)        .add(&quot;password&quot;, &quot;123456&quot;)        .build();Request request = new Request.Builder()        .url(&quot;https://valpha.xyz/testserver/loginpost.php&quot;)        .post(requestBody)        .build();\n\n\nPOST 上传文件 \n\nFile path = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);File file = new File(path, &quot;vimHotKeys.png&quot;);RequestBody body = new MultipartBody.Builder()        .addFormDataPart(&quot;file&quot;, &quot;vimHotKeys.png&quot;, RequestBody.create(MediaType.parse(&quot;image/png&quot;), file))        .build();final Request request = new Request.Builder()        .url(&quot;https://valpha.xyz/testserver/upload_file.php&quot;)        .post(body)        .build();\n\n\n下载文件\n\nOkHttpClient client = new OkHttpClient.Builder()        .connectTimeout(10, TimeUnit.SECONDS)        .readTimeout(20, TimeUnit.SECONDS)        .writeTimeout(120, TimeUnit.SECONDS)        .build();Request request = new Request.Builder()        .url(&quot;https://valpha.xyz/testserver/noByBy.mp3&quot;)        .build();\n\n\n\nClient 发起连接请求，并获取 Response 对象加载结果发起连接分为两种：同步请求和异步请求\n\n同步请求client.newCall(request).execute();，需要自己写在子线程中运行。并对Response自行处理 Response \n\nnew Thread(new Runnable() &#123;    @Override    public void run() &#123;        try &#123;            ...            Response response = client.newCall(request).execute();                        if (response.isSuccessful()) &#123;                //\tTODO:Do something with response.body()                ResponseBody responseBody = response.body();                ...            &#125;            ...        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;).start();\n\n\n异步请求client.newCall(request).enqueue();，自动调用子线程，不需要手动写入子线程中，但需要实现一个 Callback 对象\n\nCallback responseCallback = new Callback() &#123;    @Override    public void onFailure(Call call, IOException e) &#123;        // TODO:Do something when requestCall failed     &#125;    @Override    public void onResponse(Call call, Response response) throws IOException &#123;        // TODO:Do something with response.body()    &#125;&#125;client.newCall(request).enqueue(responseCallback);\n\n回调结果中，可以使用response.isSuccessful 来判断是否成功（等价于 responseCode == 200）成功后使用response.body()来获取返回的报文本体\nResponseBody responseBody = response.body();InputStream in = responseBody.byteStream();// 使用网络流下载文件\n\n\n","categories":["实习"],"tags":["Android","Android开发"]},{"title":"Android开发——六大布局绘制","url":"/2019/08/04/Android%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%85%AD%E5%A4%A7%E5%B8%83%E5%B1%80%E7%BB%98%E5%88%B6/","content":"Android 六大布局绘制线性布局、约束布局*、相对布局、帧布局、表格布局、网格布局\n\n\n共通属性布局宽度和高度(width、height)\nlayout_width：布局的宽度\nlayout_height：布局的高度\n\n可选值：\n\n&quot;match_parent&quot;：继承父系\n&quot;wrap_content&quot;：包裹内容\n_dp：固定长度（以dp为单位）\n\n&lt;LinearLayout    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;&gt;\t...&lt;/LinearLayout&gt;\n\n\n\n对齐方式(gravity)\ngravity：组件内部元素的对齐方式\nlayout_gravity：组件在父系布局中的对齐方式\n\n区别：\n\n可选值：\n\n\n\nValue\nDescription\n\n\n\ntop\nPut the object at the top of its container, not changing its size. 将对象放在其容器的顶部，不改变其大小.\n\n\nbottom\nPut the object at the bottom of its container, not changing its size. 将对象放在其容器的底部，不改变其大小.\n\n\nleft\nPut the object at the left edge of its container, not changing its size. 将对象放在其容器的左侧，不改变其大小.\n\n\nright\nPut the object at the right edge of its container, not changing its size. 将对象放在其容器的右侧，不改变其大小.\n\n\ncenter_vertical\nPlace object in the vertical center of its container, not changing its size. 将对象纵向居中，不改变其大小. 垂直对齐方式：垂直方向上居中对齐。\n\n\nfill_vertical\nGrow the vertical size of the object if needed so it completely fills its container. 必要的时候增加对象的纵向大小，以完全充满其容器. 垂直方向填充\n\n\ncenter_horizontal\nPlace object in the horizontal center of its container, not changing its size. 将对象横向居中，不改变其大小. 水平对齐方式：水平方向上居中对齐\n\n\nfill_horizontal\nGrow the horizontal size of the object if needed so it completely fills its container. 必要的时候增加对象的横向大小，以完全充满其容器. 水平方向填充\n\n\ncenter\nPlace the object in the center of its container in both the vertical and horizontal axis, not changing its size. 将对象横纵居中，不改变其大小.\n\n\nfill\nGrow the horizontal and vertical size of the object if needed so it completely fills its container. This is the default. 必要的时候增加对象的横纵向大小，以完全充满其容器.\n\n\nclip_vertical\nAdditional option that can be set to have the top and/or bottom edges of the child clipped to its container’s bounds. The clip is based on the vertical gravity: a top gravity clips the bottom edge, a bottom gravity clips the top edge, and neither clips both edges.附加选项，用于按照容器的边来剪切对象的顶部和/或底部的内容. 剪切基于其纵向对齐设置：顶部对齐时，剪切底部；底部对齐时剪切顶部；除此之外剪切顶部和底部.垂直方向裁剪\n\n\nclip_horizontal\nAdditional option that can be set to have the left and/or right edges of the child clipped to its container’s bounds. The clip is based on the horizontal gravity: a left gravity clips the right edge, a right gravity clips the left edge, and neither clips both edges.附加选项，用于按照容器的边来剪切对象的左侧和/或右侧的内容. 剪切基于其横向对齐设置：左侧对齐时，剪切右侧；右侧对齐时剪切左侧；除此之外剪切左侧和右侧.水平方向裁剪\n\n\n留白(margin)\nmargin：整体留白\nmargin*：某一方向的留白（Top、Bottom、Left、Right等）\n\n可选值：\n\n_dp：固定长度（以dp为单位）\n\n填补(padding)\npadding：整体填补\npadding*：某一方向的填补（Top、Bottom、Left、Right等）\n\n可选值：\n\n_dp：固定长度（以dp为单位）\n\n二者的关系：\n\n唯一标识(ID)\nid：ID\n\n格式：\n\n&quot;@+id/viewname&quot;：以 @+id/开头，后面跟上此控件的ID\n\n线性布局（Linear Layout）最常用的布局。特点：线性排列\n\n方向(orientation)\norientation：线性布局的方向\n\n可选值：\n\nvertical：垂直方向\nhorizontal：水平方向\n\n约束布局（Constraint Layout）官方推荐的布局。特点：按照约束布局组件\n按照边界约束的方式来规划布局，推荐使用 Design 方式来拖动约束点。\n类似 Autodesk CAD 的约束方式，按照条件来约束组件。\n\n\n小图使用了四个约束，将四个边约束到了唱片的四个边上，使得小图在唱片图层上居中显示，并且可以随唱片移动\n唱片上下边与左侧封面的上下便对齐，使得它垂直居中，然后将左边与封面的左侧约束，并手动设置dp距离，使唱片的中线显示在封面的右边界处。\n下侧封面倒影的上边与封面的下边约束在一起，边距设为0dp，左右边与封面的左右边约束在一起，使得封面与倒影水平对齐。\n整体的约束布局采用包裹内容的方式，此时只要移动外界的约束布局，即可实现内部组件的整体移动，不会发生错位的情况。\n\n\n相对布局（Relative Layout）使用相对位置的布局。特点：相对其他组件的布局方式\n传统布局，功能上不如约束布局强大，优点是比约束布局便于使用。\n采用边对齐\n帧布局（Frame Layout）特点：多个重叠放置在布局左上角，布局内不可设定各组件的相对关系。适合前景+背景的组合方式。\n表格布局（Table Layout）不常用\n网格布局（Grid Layout）不常用\n\n","categories":["实习"],"tags":["Android","Android开发"]},{"title":"Android开发——权限管理","url":"/2019/08/04/Android%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","content":"Android 权限管理\n\nAndroid 6.0 (API 23) 之后，Android 系统对权限管理进行了较大的变化。\n\n\n\n旧版本（小于 6.0 | API23）\n新版本（大于等于 6.0 | API23）\n\n\n\n只需要在Manifest中写入权限即可获取权限\n不仅要写入Manifest，部分敏感权限需要用户手动确认开启\n\n\n静态权限配置Manifest中加入以下一条权限（拨打电话和外部访问）\n&lt;manifest ...&gt;    &lt;!--如果不添加动态申请权限的询问，需要用户手动的在设置中开启相应的权限--&gt;    &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;    ...&lt;/manifest&gt;\n\n即可在程序设置中看到所申请的权限\n\n可以在这里手动给予权限。但更明智的方法时使用动态申请权限——在需要使用权限的时候（或程序第一次启动时）检查是否拥有权限，若没有的话则申请权限。\n动态申请权限首先判断当前的版本，如果 Android 版本高于6.0 (API 23)，那么就需要动态申请权限，否则不需要。\n然后使用requestPermissions方法来申请我们需要的权限\n官方推荐的写法\n效果：\n\n注意：这里，第一次点击*deny，是拒绝权限；第二次点allow**，是同意了权限，但是并不会拨出电话。第三次点击拨号，此时有了拨号权限，所以才可以拨出电话。这就很蠢，UE需要优化。 在同级添加一个申请权限结果的反馈，利用toast做输出  测试结果：\n  \n在反馈结果中，如果获得了权限，是可以直接执行意图的，即直接拨号，达到了最佳体验。\n开源框架 EasyPermission 的用法在 Github 上有很多开源的框架，可以方便开发者快速开发。例如 EasyPermission、FindViewByMe等等\n这里可以使用EasyPermission来方便地进行动态权限的申请。\ngooglesamples/easypermissions | GitHub\n官方使用介绍：\n先在build.gradle中添加dependencies\n然后再程序中使用：\npublic class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);    &#125;    @Override    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123;        super.onRequestPermissionsResult(requestCode, permissions, grantResults);        // Forward results to EasyPermissions        EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);    &#125;&#125;\n\n\n\n\n获取拨号和写入权限：\n//  开源权限管理@AfterPermissionGranted(RC_CALL_PHONE_AND_WRITE_SDCARD)private void methodRequiresTwoPermission() &#123;    String[] perms = &#123;Manifest.permission.CALL_PHONE, Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;;    if (EasyPermissions.hasPermissions(this, perms)) &#123;        // Already have permission, do the thing        Toast.makeText(this, &quot;已经获取权限啦&quot;, Toast.LENGTH_SHORT).show();        startActivity(intent);    &#125; else &#123;        // Do not have permissions, request them now        EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale),                RC_CALL_PHONE_AND_WRITE_SDCARD, perms);    &#125;&#125;\n\n效果展示：\n\n方便快捷。\n\n","categories":["实习"],"tags":["Android","Android开发"]},{"title":"Android Studio 常用插件","url":"/2019/08/04/Android%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94Android%20Studio%20%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/","content":"Android Studio 常用插件\n\nMaterial Theme 主题一个非常现代化的主题，提供多种配色。\n推荐使用 Oceanic Theme 主题配色。\n\n都9012年了，IDE也要跟得上审美啊，不然从何提高效率！\n\nWakaTime 编码时长统计插件一个用于统计近期 Coding 时长的插件。\n原理是当你打开 Android Studio IDE 后自动开始计时，并将使用时长发送到 Wakatime 的服务器上。可以通过访问 Wakatime 网站的 DashBoard 来查看自己近期的 Coding 情况。\n\n装X必备，统计时间必备！\n\nDashBoard\n\nEmbeddable Charts\n将近期的Coding Activity 绘制成图标嵌入到网页上。如下图\n\n### Alibaba Java代码规范检查\n\n在 Android Studio 中安装 Alibaba 代码规范检查插件，可以方便地进行代码规范性检查。\n安装插件后，在tools中选择阿里编码规约，然后检查单文件or项目工程 可以得到一个检查报告。\n其中Critical级别的报告必须更改，Major的尽量修改。\n具体要求看各公司要求。\nRainbow Brackets 彩虹括号对使你的代码变得更加绚丽多彩！\n增强在代码为对齐时的可读性，按照色彩去匹配括号对。\n\n好看就完事了。\n\n\n\n","categories":["实习"],"tags":["Android","Android技巧"]},{"title":"Android 开源框架","url":"/2019/08/05/Android%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94Android%20%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/","content":"Android 开源框架\n\nOKHTTP——开源HTTP，替换HttpURLConnection\nHTTP is the way modern applications network. It’s how we exchange data &amp; media. Doing HTTP efficiently makes your stuff load faster and saves bandwidth.\nOkHttp is an HTTP client that’s efficient by default:\n\nHTTP/2 support allows all requests to the same host to share a socket.\nConnection pooling reduces request latency (if HTTP/2 isn’t available).\nTransparent GZIP shrinks download sizes.\nResponse caching avoids the network completely for repeat requests.\n\nOkHttp perseveres when the network is troublesome: it will silently recover from common connection problems. If your service has multiple IP addresses OkHttp will attempt alternate addresses if the first connect fails. This is necessary for IPv4+IPv6 and for services hosted in redundant data centers. OkHttp supports modern TLS features (TLS 1.3, ALPN, certificate pinning). It can be configured to fall back for broad connectivity.\nUsing OkHttp is easy. Its request/response API is designed with fluent builders and immutability. It supports both synchronous blocking calls and async calls with callbacks.\n\nokhttp | Github.com\n安装build.gradle\nimplementation(&quot;com.squareup.okhttp3:okhttp:3.4.1&quot;)\n\n使用方法与Http协议规定的一致，客户端发起request，服务端收到后提供response。\nstart=&gt;start: 创建 OkHttpClient 对象end=&gt;end: 成功op1=&gt;operation: 利用 Request.Builder() 创建一个 Request 对象op2=&gt;operation: 使用 Client 调用 newCall(Request) 方法返回一个 Response 对象op3=&gt;operation: 对 Response 对象进行操作start-&gt;op1-&gt;op2-&gt;op3-&gt;end\n\n编码逻辑\n创建 OkHttpClient 对象\nOkHttpClient client = new OkHttpClient();\n创建Request对象，并设置URL、Body等其他属性\nRequest request = new Request.Builder()    .url(&quot;https://valpha.xyz/testserver/loginget.php?username=zhangsan&amp;password=123456&quot;)    .build();\n同步或异步发送请求，并获取Response对象\n\n同步请求client.newCall(request).execute();，需要自己写在子线程中运行。并对Response自行处理 **response 回调结果中，可以使用response.isSuccessful 来判断是否成功（等价于 responseCode == 200）\n\nnew Thread(new Runnable() &#123;    @Override    public void run() &#123;        try &#123;            ...            Response response = client.newCall(request).execute();                        if (response.isSuccessful()) &#123;                //\tTODO:Do something with response.body()                ResponseBody responseBody = response.body();                ...            &#125;            ...        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;).start();\n\n\n异步请求client.newCall(request).enqueue();，自动调用子线程，不需要手动写入子线程中，但需要实现一个 Callback 对象\n回调结果中，可以使用response.isSuccessful 来判断是否成功（等价于 responseCode == 200）\n\n\nCallback responseCallback = new Callback() &#123;    @Override    public void onFailure(Call call, IOException e) &#123;        // TODO:Do something when requestCall failed     &#125;    @Override    public void onResponse(Call call, Response response) throws IOException &#123;        // TODO:Do something with response.body()    &#125;&#125;client.newCall(request).enqueue(responseCallback);\n成功后使用response.body()来获取返回的报文本体\nResponseBody responseBody = response.body();InputStream in = responseBody.byteStream();// 使用网络流下载文件\n\nEasyPermissions——简化Android权限申请\nEasyPermissions is a wrapper library to simplify basic system permissions logic when targeting Android M or higher.\n\nEasyPermissions | Github.com\n安装build.gradle\ndependencies &#123;    // For developers using AndroidX in their applications    implementation &#x27;pub.devrel:easypermissions:3.0.0&#x27;     // For developers using the Android Support Library    implementation &#x27;pub.devrel:easypermissions:2.0.1&#x27;&#125;\n\n使用\nThe example below shows how to request permissions for a method that requires both CAMERA and ACCESS_FINE_LOCATIONpermissions. There are a few things to note:\n\nUsing EasyPermissions#hasPermissions(...) to check if the app already has the required permissions. This method can take any number of permissions as its final argument.\nRequesting permissions with EasyPermissions#requestPermissions. This method will request the system permissions and show the rationale string provided if necessary. The request code provided should be unique to this request, and the method can take any number of permissions as its final argument.\nUse of the AfterPermissionGranted annotation. This is optional, but provided for convenience. If all of the permissions in a given request are granted, all methods annotated with the proper request code will be executed(be sure to have an unique request code). The annotated method needs to be void and without input parameters (instead, you can use onSaveInstanceState in order to keep the state of your suppressed parameters). This is to simplify the common flow of needing to run the requesting method after all of its permissions have been granted. This can also be achieved by adding logic on the onPermissionsGranted callback.\n\n@AfterPermissionGranted(RC_CAMERA_AND_LOCATION)private void methodRequiresTwoPermission() &#123;    String[] perms = &#123;Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION&#125;;    if (EasyPermissions.hasPermissions(this, perms)) &#123;        // Already have permission, do the thing        // ...    &#125; else &#123;         // Do not have permissions, request them now        EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale),                RC_CAMERA_AND_LOCATION, perms);    &#125;&#125;\n\nOr for finer control over the rationale dialog, use a PermissionRequest:\nEasyPermissions.requestPermissions(        new PermissionRequest.Builder(this, RC_CAMERA_AND_LOCATION, perms)                .setRationale(R.string.camera_and_location_rationale)                .setPositiveButtonText(R.string.rationale_ask_ok)                .setNegativeButtonText(R.string.rationale_ask_cancel)                .setTheme(R.style.my_fancy_style)                .build());\n\nOptionally, for a finer control, you can have your Activity / Fragment implement the PermissionCallbacks interface.\npublic class MainActivity extends AppCompatActivity implements EasyPermissions.PermissionCallbacks &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);    &#125;    @Override    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123;        super.onRequestPermissionsResult(requestCode, permissions, grantResults);        // Forward results to EasyPermissions        EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);    &#125;    @Override    public void onPermissionsGranted(int requestCode, List&lt;String&gt; list) &#123;        // Some permissions have been granted        // ...    &#125;    @Override    public void onPermissionsDenied(int requestCode, List&lt;String&gt; list) &#123;        // Some permissions have been denied        // ...    &#125;&#125;\n\n使用EasyPermissions#hasPermissions(...)来检查是否存在权限\n使用EasyPermissions#requestPermissions来申请权限\n使用@AfterPermissionGranted(...)注释来标记获取权限后要执行的命令\n","categories":["实习"],"tags":["Android","Android技巧"]},{"title":"JVM","url":"/2019/09/24/JVM/","content":"Java虚拟机内存模型\n\nJVM虚拟机剖析JVM结构\n栈\n\n每一个方法，分配一个栈帧\n首次调用会入栈，调用结束后会出栈。\njavap -c 反编译java class文件，可以得到JVM底层代码\n每一个线程（栈帧）都有自己的程序计数器（标识行号）\n\n","categories":["Java学习"],"tags":["JAVA","JVM"]},{"title":"Mastering RecyclerView","url":"/2020/02/08/RecyclerView%E8%A7%A3%E8%AF%BB/","content":"RecyclerView.LayoutManager 工作原理详解\nBilibili: Mastering ReyclerView Layouts\n\n\nRecyclerView一个可以对视图进行回收利用的ViewGroup\n通过回收机制，使得一个小屏幕上可以显示成千上万个内容（节约内存）\n是一套方便开发者自定义的FrameWork\n利用LayoutManager来管理View的位置、动画等；使用Adapter来管理View的内容\n\nScrap Heap、Recycle Pool？仍然存在屏幕上的View-&gt; Scrap Heap-&gt; 取出继续使用\n移除屏幕的View-&gt; Scrap heap-&gt; Recycle Pool-&gt; Recycler重新bind Adapter\n\nScrap Heap: detachAndScrapView()\nRecycle Pool: removeAndRecycleView()\n\nLayoutManager方便实用的三个已经集成的LayoutManager\nLinearLayoutManager\n基本等同于ListView，比传统的ListView多一个横向滚动的功能\n\n\nGridLayoutManager\n目的是替代传统的GridView，但是更强大：可以设置一个SpanSize的Lookup表，如下图。\n可以自由设置每一行（列）的span数，来决定这一行的View数。每一行（列）的高度（宽度）是统一的，若子View尺寸不统一，很有可能造成留白的现象。\n\n\nStaggeredGridLayoutManager\n可以实现瀑布流，后面的View会自动向前（上）填充。\n\n\n\nMeasure：给View做装饰：getDecoration()\ngetDecoratedTop()\ngetDecoratedLeft()\ngetDecoratedBottom()\ngetDecoratedRight()\ngetDecoratedWidth()\ngetDecoratedHeight()\n\n对列表内的Item提供一个经过装饰后的位置坐标，用来Measure用的\nlayoutDecorated()对装饰后的View进行布局\nmeasureChild()测量子View\n“Fill”技术\nfillGaps()\nDiscover first visible position/location\nFind layout gaps (at the edges)\nScrap everything\nLay out all visible positions\n\n简单来说，就是一种“填充”的概念\n一个函数，封装了Layout过程中所有需要的操作\n最主要的步骤如下：\n\n找到一个可视元素的位置\n计算出Gap（留白）或offset（偏移量）\n把所有的View都留给Scrap Heap（Recycle Pool）\n重新布局\n\n使用这个Fill函数的好处就是不需要考虑当前Layout所处的状态是初始化、滑动后的重新布局还是RecyclerView发生任何状态改变，只要需要重新布局的地方，全部使用这一个Fill函数，完成所需要的布局即可\n这个方法并不会很影响性能，因为Scrap Heap中并不会改变View的属性（Recycle Pool会），只有确实发生改变的View才会改变其属性（进入Recycle Pool）\n\nSave as little state as possible\n\n尽可能少地存储状态\n你需要的数据（gap、offset、position等）需要重新寻找和计算出来，不要尝试去记录这些数据。会遇到各种边界的坑。\nFill函数示例\nprivate void fillGrid(int direction, ...,                      RecyclerView.Recycler recycler,                      RecyclerView.State state)&#123;    //...Obtain the first visible item position...    //第一步回收所有的View    detachAndScrapAttachedViews(recycler);        //之后遍历所有的View，找到我需要布局的View，add到ViewGroup中，然后measure、Layout等    for(...)&#123;        int nextPosition = ...;        View view = recycler.getViewForPosition(nextPosition);        addView(view);                measureChildWithMargins(view, ...);        layoutDecorated(view, ...);    &#125;        //Remove anything that is left behind    //最后把不需要的View回收掉（真正进入Recycle Pool中）    final List&lt;RecyclerView.ViewHolder&gt; scrapList = recycler.getScrapList();    for (int i=0; i &lt; scrapList.size(); i++)&#123;        final View removingView = scrapList.git(i);        recycler.recycleView(removingView);    &#125;    &#125;\n\n让自定义的LayoutManager“跑起来”1. onLayoutChildren()这是一个 “initial method”，当布局初始化时或RecyclerView的大小发生改变时才会调用，不会被重复调用\n在这里面运行一个“Fill”函数\n2. canScrollVertically()orcanScrollHorizontally()通知framework，允许水平滚动or垂直滚动（or两个都返回true，这就是一个双向滚动的View）\n3. scrollHorizontallyBy()andscrollVerticallyBy()真正处理滚动操作的method，会一直重复地调用\n方法职责：\n\n提供framework认为你的View应该滚动的距离delta。输入参数\n\n处理水平（垂直）滚动操作\n\n到边界时（开头、末尾）应当停止滑动。通过返回值进行判断\n\n\n例子\npublic int scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state) &#123;    //dx是framework提供的用户输入信息，不代表真实的滑动距离    int delta;// 此处的delta才是真正的滑动距离    if (dx &gt; 0) &#123; // Contents are scrolling left        delta = ...;    &#125; else &#123; // Contents are scrolling right        delta = ...;    &#125;    //不需要手动移动所有的view，只需计算偏移量，并且调用framework的API即可    offsetChildrenHorizontal(delta);    if (dx &gt; 0) &#123;        fillGrid(DIRECTION_START, ...,recycler, state );    &#125; else &#123;        fillGrid(DIRECTION_END, ...,recycler, state );    &#125;    // 返回值必须是真实滑动距离的负数    return -delta;&#125;\n\n\n\nData Set ChangesonAdapterCHanged()这个方法会在重新setAdapter(adapter)时调用，此时一定是一个全新的dapter和数据集，View已经全部改变了，可以直接把所有的View给remove掉，removeAllViews()，作为一个优化。\nnotifyDataSetChanged()-&gt;onLayoutChanged()notifyDataSetChanged 等于触发一次 onLayoutChanged，如果“Fill”方法写得好，那么运行一次fill就会自动布局好一切。或者你需要查找并保存一下position。\nAdd Some Flair 添加一些额外的功能scrollToPosition()让RecyclerView滚动到指定位置。\n两步走：\n\n定位需要移动到的位置position\nrequestLayout()-&gt;onLayoutChanged()-&gt;FILL方法\n\nsmoothScrollToPosition()\n如果是带动画的移动效果\n\n创建一个SmoothScroller的帮助类\n\n实现抽象的方法\n\n\nor\n\n使用（继承）LinearSmoothScroller来进行工作\n\nLinearSmoothScroller例子\n@Overridepublic void smoothScrollToPosition(RecyclerView recyclerView, final RecyclerView.State state, int position) &#123;    LinearSmoothScroller scroller = new LinearSmoothScroller(recyclerView.getContext())&#123;        @Nullable        @Override        public PointF computeScrollVectorForPosition(int targetPosition) &#123;            final int rowOffset = ...;            final int columnOffset = ...;                        return new PointF(columnOffset * stepWidth, rowOffset * stepHeight);        &#125;    &#125;;    scroller.setTargetPosition(position);    startSmoothScroll(scroller);    &#125;\n\n","categories":["笔记"],"tags":["Android","RecyclerView"]},{"title":"一月考核后的第一节课","url":"/2019/07/31/%E4%B8%80%E6%9C%88%E8%80%83%E6%A0%B8%E5%90%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE/","content":"利用shape画图、自定义seekbar、从服务器获取数据\n\n\nshadow 阴影显示&lt;TextView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:textColor=&quot;#333&quot;        android:gravity=&quot;center&quot;        android:shadowColor=&quot;#999&quot;        android:shadowDx=&quot;10&quot;        android:shadowDy=&quot;10&quot;        android:textSize=&quot;50sp&quot;        android:shadowRadius=&quot;5&quot;        android:text=&quot;Hello World!&quot; /&gt;\n\n\nshape画图\n画线\n画椭圆\n画矩形\n画圆\n\n\nsize 指定尺寸\n\nsolid 内部填充颜色\n\nstroke 边缘设计\n\n\ngradient 渐变设计\n\n\n\n\n\nLayer-list 组合多图形\n\n\nShapeSelector\n","categories":["实习"],"tags":["Android","实习日记"]},{"title":"使用BT面板并配置HTTPS访问","url":"/2019/06/30/%E4%BD%BF%E7%94%A8BT%E9%9D%A2%E6%9D%BF%E5%B9%B6%E9%85%8D%E7%BD%AEHTTPS%E8%AE%BF%E9%97%AE/","content":"建站记录\n\n\n自从改用宝塔面板控制后，发现果然GUI界面更适合我，博客逐渐更像个“博客”了。\n利用宝塔面板，一键安装LAMP环境、部署Wordpress、开启SSL，301重定向……一切都显得那么信手拈来233~(●ˇ∀ˇ●)\n这篇博文就用来纪念成功的给自己的小网站“上锁”吧\nPS：开始考虑域名和备案信息等问题了，感觉没有一个固定的域名，就好像一直在租房子住似的，感觉不久之后就会流离失所，没有安全感……\n","categories":["建站"],"tags":["服务器","里程碑"]},{"title":"剑指Offer（一）","url":"/2019/06/29/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%80%EF%BC%89/","content":"第一章——面试的流程\n\n\n第一章——面试的流程1.2面试形式：\n  电话面试\n  共享桌面远程面试\n  现场面试\n\n共享桌面远程面试（或提供一个WEB）要点：\n  思考清楚再开始coding\n  良好的命名\n  正确的缩进\n能够进行单元测试用例*  优秀的码农应当学会如何测试自己的代码，面试官会对“先写测试后写代码”的程序员刮目相看。\n  熟练的debug能力\n\n1.3面试环节：\n  行为面试\n  技术面试\n  应聘者提问\n\n行为面试聊天、问项目、谈理想等\n技术面试应聘者需要具备的素质：1. 扎实的基础知识（语言、数据结构、算法）2. 写出正确、完整、鲁棒的高质量的代码3. 思路清晰地分析、解决问题4. 时间、空间复杂度两方面进行优化算法效率5. 沟通能力、学习能力、发散思维能力\n应聘者提问切记：不要问技术人员薪水，对正确的人提合适的问题\n","categories":["笔记"],"tags":["剑指Offer","读书笔记"]},{"title":"剑指Offer（二）","url":"/2019/06/30/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"第二章——基础知识\n\n\n第二章——基础知识2.2 编程语言C++/C#、不是我学习的重点……略过\n2.3 数据结构数组、字符串、链表、树、栈、队列\n数组、字符串是最基础的数据结构，占用连续内存链表、树要注意指针越界问题，防止指针越界导致程序崩溃栈——递归算法队列——广度优先遍历\n2.4","categories":["笔记"],"tags":["剑指Offer","读书笔记"]},{"title":"华为面经","url":"/2020/03/08/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E7%BB%8F/","content":"我的面试经历面试岗位：华为-消费者事业群Android开发\n\n\n本人坐标大连，去年年底秋招补录过的。申请岗位是消费者bg的Android开发。距离面试刚好两个月了，趁还有些记忆写点东西记录一下备忘。\n机试华为标准三道题。\n\n第一道基本功，折腾字符串和标准输出。\n第二道是算法题，奥特曼打怪兽，从n方阵的左上角走到右下角，然后再返回起点。有三种格点：值为0，正常可通过；值为1，奥特曼可通过，同时还可以消灭怪兽，消灭后值变为0且怪兽不会复活，消灭怪兽数量+1；值为-1，有大石头，奥特曼无法通过。怪兽死后不会复活。求奥特曼可以消灭怪兽的最大数量。\n解题时用回溯法，时间复杂度挺高……这道题C++给时为2s（其他题目只有1s）说明允许使用高复杂度的算法解题，于是乎不管最优解，硬刚就完事了。写完算法没AC，只有66.6%的通过率，可能有些细节没考虑到。第三题是日志格式化输出，给定长日志输入，按照需求把相关的报错信息输出并计算出错时长等信息。也比较简单，还是折腾字符串和Map，利用好Map和List很容易解题。专业一面华为一面为技术面，在笔试结束后大约1周内收到了面试通知。华为是一天三面全部安排完，为了招聘的高效率吧……但是对于求职者来说还挺低效的😛问了大概以下几个问题：\n介绍自己和相关项目（相关项目问的不深，主要还是问职责和遇见的问题和解决措施\nSocket相关知识点\nAndroid Binder 进程通信的原理，以及AIDL开发（简历里写了这一项，重点询问。不过我答得不是特别好，就会打了个大概，描述清楚了怎么使用而已\nHandler，MessageQueue、Looper相关原理\nJVM内存模型\nJava Native 使用方法以及JNI的编写方法（项目中用到过，回答的比较全\n是否读过Android源码（回答很套路：在读……\nAndroid内存回收（项目里没遇到，只说了自己了解的一小部分\n手撕代码，挺简单的一道题……基本难度那种，印象不深刻忘记了😂一面挺快就结束了，一共也就40分钟左右，问的不是很深，而且我是有一些实习经历和项目经历的，估计面试官把重点问题都留给二面了。\n\n专业二面​二面面试官明显是个团队Leader级别的人物，气质跟第一面完全不同。上来直接介绍自己和项目，并对项目一通追问。项目详情：Socket内网通信，使用TCP协议，出现了丢包问题，怀疑是路由器质量差，丢包延迟问题严重。通过C/S联调以及更换路由器后，改善延时，但仍有丢包。后续发现是代码逻辑bug，缓冲区长度限制导致了阻塞。大概就是这么个项目，然后这位面试官从一路追问，刨根问底问具体是什么情况导致的延迟丢包问题，从路由器问到ReceiveBuffer，最后得意地发现其实路由器质量不是根本问题，代码逻辑bug才是😐（其实我简历上没写那么多……一句话带过了而已，就这样追问了大概十分钟……然后是开始提问：\n\nJava 里 static 修饰 类、变量、方法各有什么含义？（我Java基础差，答得不是特别好，零零星星回答的，没有逻辑\nAndroid Binder（一面问过，这次问的更深，探讨了什么是Android的DataBinding技术。这个项目经历中有用过，我结合MVVM谈了下理解\nHandler 和 MessageQueue相关问题（没错，也是一面问过的，都是重点啊\nGit 中 merge 和 rebase 的区别（我：？？？，面试官看我简历里有些熟练使用Git，然后问我这两个操作的区别……我从没准备过这种问题，谈了谈大概的用法，但是没说清楚具体的区别。最后只能说，我会用，但具体区别我说不明白😂\n设计模式，直接手撕代码，实现一个单例模式。（这个用的多，比较熟悉，直接写了个饿汉式出来。完了面试官询问写的是什么模式，也就顺利过了。\n手撕代码：输入一个字符串，输出最大回文字符串。（也是入门题目，leetcode上忘了是初级还是中级了，以前做过但是生疏了……用了挺长时间，但是没做全，有种情况没考虑到。XXXABAXX……这种写好了，但是XXABBAX……这种完全没考虑到。面试官觉得勉强过但是又不够好😂于是又给我出了一道题\n手撕代码：输入一个（有序）数组，然后给定一个范围，左界和右界，输出这俩的交集。（我没注意到数组是有序的，写这个算法多花了点时间去排了个序，然后再输出。题目比较简单，也就快速过了。因为写代码时间比较多，二面问了一个半小时左右。面完了心力交瘁……最后面试官给我个评语：勉强给你过了，但是你基础不够好，如果来本公司上班，要自己抽时间巩固基础。所以基础还是重要哇……\n\n主管面第三面是主管面，基本就家庭啊，职业规划啊，预期城市啊啥的。​也简单问了问项目，但还是对问的的解决策略和担任的职责去提问。还问了为什么选择华为，以及选择这个岗位。还有对待996加班的看法。面试华为的同学应该要对这个问题体现想好自己的看法对了，还有成绩单。主管面会看学校成绩。大概20多分钟就完事了。之后就是等通知结果了。\n总结本人是电子通信工程专业，本科应届生。学的知识其实和Android不是那么搭边，最后也是凭借个人兴趣和发展规划选择了Android开发这条路，对专业来说，算是半个科班生。Java语言和Android也是半年前才接触的，只能说，编程这东西是相通的，理解算法和数据结构远比只学某种语言更重要；而且解决问题的逻辑也比重复机械地背代码重要。再就是要有创新精神，做技术要与时俱进，时刻关注新技术，随时更新自己的技术栈才能保证自己不落伍。大公司需要的都是能干活的员工，提升自己解决问题的能力很重要，相比学校里学习的理论知识，实战项目更看重debug能力。\n最后，这篇文章也挺长的，希望所有能看到这里的同学都能还愿大家加油\n","categories":["求职"],"tags":["华为","面经"]},{"title":"博客再次重建","url":"/2019/07/06/%E5%8D%9A%E5%AE%A2%E5%86%8D%E6%AC%A1%E9%87%8D%E5%BB%BA/","content":"再一次回到Hexo搭建个人博客……\n\n\n从WordPress回来，中途经停了Typecho，最后还是觉得Hexo比较适合我。\n纯粹的Markdown编写，渲染使用一步到位，Next主题美观且大方，不需要从那么多不知名的插件和主题中费劲挑选。\nPs：Typecho的Handsome主题确实很好，但是碍于收费问题。。整个博客还没一个收费主题要价高，算了算了……\n\n","categories":["建站"],"tags":["服务器","里程碑"]},{"title":"博客建成里程碑","url":"/2019/06/16/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E6%88%90%E9%87%8C%E7%A8%8B%E7%A2%91/","content":"正式上线\n\n\n2019年6月16日，正式建成自己的博客~成功地完成了域名、服务器、备案等所有的过程，正式开启了自己的博客生涯~\n记录以下博客的所有材料：\n\n  轻量应用服务器（ 10元/月，学生特价）\n  顶层域名（6元/年，.xyz域名）\n\n然后是漫长的备案过程：\n\n  填申请表单\n  电话确认信息以及相关信息修改\n  邮寄幕布以及幕布拍照\n  地方管理局域名备案\n  备案完成！正式使用域名valpha.xyz来访问我的博客啦~\n\n6月30日，更改博客形式，改成使用BT面板，自行安装Wordpress的方式来部署博客\n好处在于方便管理，自行决定服务器、数据库版本设置，也方便操作，从应用层面备份网站，不需要每次都是硬件级的备份（快照）\n","categories":["建站"],"tags":["服务器","里程碑"]},{"title":"实习Day1","url":"/2019/07/02/%E5%AE%9E%E4%B9%A0Day1/","content":"实习Day1\n\n  学习部分专属名词\n  嵌入式车载开发的整体结构\n  SOC、MCU的区别\n  程序员的发展规划\n\n专属名词：\n\n  SOC：\n  MCU：\n  IVI：\n  infotainment：\n  T-Box（Telematics-box）：\nOBD：\n  doIP：\n  someIP：\n\n\n  OTA：\n  VR（voice recognition）：\n  cluster：\n  DMS：\n  ADAS：\n  AVM：\n  cockpit：\n  DMIPS：\n\n车载域：\n\n  动力域\n  自动驾驶域\n  信息娱乐域\n  车身域\n\n总线：\n\n  CAN\n  LIN\n  FlexRay\n  ethernet\n  USB\n\n开发环境：\n\n  RT-OS\n  *QNX\n  Linux\n  Android\n\n车载温度：-40～85度\n\n车机娱乐域结构图\n\nSOC与MCU上电过程\n","categories":["实习"],"tags":["Android","实习日记"]},{"title":"实习Day10","url":"/2019/07/14/%E5%AE%9E%E4%B9%A0Day10/","content":"设计模式\n\n\n设计模式什么是设计模式？可重复使用的代码设计经验总结\nOO原则\n单一职责\n不要重复代码\n开闭原则——修改关闭、扩展开放\n依赖倒置\n接口隔离——暴露接口隐藏细节\n\n观察者模式（Observer Pattern）Publisher—Listener模式\n也可理解为订阅者模式（微信公众号也是也是订阅者模式）\n结构为一个主的信息源，将自己的信息传递给多个订阅者，用户可以通过泛化来继承订阅者的方法实现特例化。\n下图为气象站Demo\n\n需要注意的是，Subject中的属性（对象）为List&lt;Object&gt;是对象的集合，用于实现notifyObserver(observers)，将数据推送至各订阅者\n每一个对象Observer的属性（对象）为Subject是主题，用于实现update(subject)，从主题方将数据拉去回来\nSubjec 和 Observer均为接口——接口分离原则\n任意的观察者都可以继承Observer的update()方法，来实现自己的特例化\n代码：接口WeatherSubject.java\npackage com.example.observerpatterndemo;public interface WeatherSubject &#123;    void registerObserver(Observer observer);    void removeObserver(Observer observer);    void notifyObservers();&#125;\n\nObserver.java\npackage com.example.observerpatterndemo;public interface Observer &#123;    public void update(float temp, float humidity, float pressure);&#125;\n\nDisplayElement.java\npackage com.example.observerpatterndemo;public interface DisplayElement &#123;    public void display();&#125;\n\n实现MVC模式（Model-View-Controller）\n工厂模式（Factory Pattern）\n引自菜鸟教程工厂模式\n\n\n工厂方法模式一种创建对象的模式，它被广泛应用在jdk中以及Spring和Struts框架中；\n工厂方法模式基于”输入”，应用在超类和多个子类之间的情况，这种模式将创建对象的责任转移到工厂类；\n\n\n代码接口类Shape.java\npublic interface Shape &#123;   void draw();&#125;\n\n实现接口的实体类Rectangle.java\npublic class Rectangle implements Shape &#123;    @Override   public void draw() &#123;      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);   &#125;&#125;\n\nSquare.java\npublic class Square implements Shape &#123;    @Override   public void draw() &#123;      System.out.println(&quot;Inside Square::draw() method.&quot;);   &#125;&#125;\n\nCircle.java\npublic class Circle implements Shape &#123;    @Override   public void draw() &#123;      System.out.println(&quot;Inside Circle::draw() method.&quot;);   &#125;&#125;\n\n创建工厂类，生成基于给定信息的实体类对象ShapeFactory.java\npublic class ShapeFactory &#123;       //使用 getShape 方法获取形状类型的对象   public Shape getShape(String shapeType)&#123;      if(shapeType == null)&#123;         return null;      &#125;              if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;         return new Circle();      &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;         return new Rectangle();      &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;         return new Square();      &#125;      return null;   &#125;&#125;\n\n使用工厂类，通过传递信息获取实体类对象FactoryPatternDemo.java\npublic class FactoryPatternDemo &#123;    public static void main(String[] args) &#123;      ShapeFactory shapeFactory = new ShapeFactory();       //获取 Circle 的对象，并调用它的 draw 方法      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);       //调用 Circle 的 draw 方法      shape1.draw();       //获取 Rectangle 的对象，并调用它的 draw 方法      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);       //调用 Rectangle 的 draw 方法      shape2.draw();       //获取 Square 的对象，并调用它的 draw 方法      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);       //调用 Square 的 draw 方法      shape3.draw();   &#125;&#125;\n\n补充对于需要获取的对象，可以使用枚举体来获取，例如：\npublic enum Event &#123;    EVT_OFF,    EVT_ACC,    EVT_IGNON,    EVT_CRANK,&#125;\n\n调用方法\nEvent.EVT_OFF, Event.EVT_ACC, Event.EVT_IGNON, Event.EVT_CRANK\n\n可以使用HashMap来存储键值对信息，便于调用\n//\tState为自定义的类//\tString为主键、State为值，创建一个新的mapHashMap&lt;String, State&gt; map;\n\n调用方法\nmap.get(&lt;Key&gt;);//\treturn Value//\t其他方法待补充\n\n\n\n单例模式（Singleton Pattern）\n单例模式|菜鸟教程\n\n\n意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n主要解决： 一个全局使用的类频繁地创建与销毁。\n何时使用：当您想控制实例数目，节省系统资源的时候。\n如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n关键代码：构造函数是私有的。\n\n\n代码样例一：Lazy Load, Thread Not Safepublic class Singleton &#123;      private static Singleton instance;      private Singleton ()&#123;&#125;        public static Singleton getInstance() &#123;      if (instance == null) &#123;          instance = new Singleton();      &#125;      return instance;      &#125;  &#125;\n\n不保险，在多线程同时运行时，一个判断null完毕尚未new出实例时，另一个线程进入判断，如果这样会导致非单例的情况出现\n样例二：Lazy Load, Thread Safepublic class Singleton &#123;    private Singleton singleton;    private Singleton()&#123;    &#125;    public static synchronized Singleton getSingleton()&#123;        if (singleton == null)&#123;            singleton = new Singleton();        &#125;        return singleton;    &#125;&#125;\n\n加入关键字synchronized开启线程锁，可以保证线程安全，可是这样会导致效率下降。\n组合模式（Composite Pattern）\n组合模式|菜鸟教程\n\n\n意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。\n何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。\n如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。\n关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。\n应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中（Android），对于 Button 和 Checkbox 是树叶，Container 是树枝。\n优点： 1、高层模块调用简单。 2、节点自由增加。\n缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。\n使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。\n注意事项：定义时为具体类.\n\n\n核心就是要实现树枝和叶子接口的统一！以此来统一管理所有的树\n数据结构中的树+统一的接口+内部List属性\n装饰者模式如同俄罗斯套娃一般，层层装饰……\n\n例如，买咖啡时，又要加糖又要加香草并且还要添加牛奶，各种组合使得方法的数量阶乘增长\n所以使用一种可以互相调用的装饰器来进行多重修饰\n\n如何解决：将具体功能职责划分，同时继承装饰者模式。\n关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。\n\n代码搬运自菜鸟教程，了解后更新\n装饰器模式|菜鸟教程\n\n","categories":["实习"],"tags":["实习日记","设计模式","UML"]},{"title":"实习Day11","url":"/2019/07/15/%E5%AE%9E%E4%B9%A0Day11/","content":"RTM 需求跟踪矩阵\n\n\n\n通过多次对需求矩阵进行更新，并随时查阅矩阵，可以高效地进行开发\n以上为用户需求跟踪，针对用户提出的需求，完善该矩阵，并逐个开发实现\n用户的需求随时可能变更，每次更新需求都要进行记录，并重置优先级\n在某一项需求开发完毕后要进行测试，测试结果需要在需求矩阵中记录\n\n","categories":["实习"],"tags":["实习日记","需求分析"]},{"title":"实习Day12","url":"/2019/07/16/%E5%AE%9E%E4%B9%A0Day12/","content":"多界面切换、利用意图调用\n\n在一个APP中使用多个界面创建新的 Activity在一个工程中新建一个界面\n\n新建界面之后会生成一个新类、新的布局\n\n并且会改写Manifest文件\n\n在启动时，默认打开最上层的界面\n\n而且会生成双APP，进不同的app可以打开两个不同的界面\n\n通过设置Manifest文件修改app名称遵守 XML语法，有以下两种修改名称的方式\n\n\n利用ImageAssert生成图标打开 ImageAssert\n\n\n效果\n\nIntent（意图）的使用利用意图，启动多界面\n界面准备绘制UI\n\n\n显式意图显式意图启动Main2界面public void startMain2(View view) &#123;    //  显式意图启动Main2界面    Intent intent = new Intent(this, Main2Activity.class);    startActivity(intent);&#125;\n\n效果：\n\n显示意图启动其他app的界面前提是知道其它要启动的app的包名和界面，必须要精确，否则无法启动导致报错。\n\n\n隐式意图筛选意图在Manifest里面设置一下activity的属性——intent-filter意图过滤器，在主程序中使用意图过滤器来筛选使用的意图\n&lt;intent-filter&gt;    &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;    &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;     &lt;/intent-filter&gt;\n\npublic void startMain3(View view) &#123;    //  使用隐式意图启动Activity    //  需要知道所要启动的Activity的意图过滤器的Action和Category    //  Data和Type不是必须的，根据意图需要完全匹配    Intent intent = new Intent();    intent.setAction(&quot;com.example.action.MAIN3&quot;);    intent.addCategory(&quot;android.intent.category.DEFAULT&quot;);    startActivity(intent);&#125;\n\n只要action和category完全一致了，就可以匹配执行意图\n\n如果定义了data则需要把data也进行匹配\n常用的方式有：\n\nscheme\nmimeType\n\nscheme对应数据格式，mimeType对应数据类型\n例如\n&lt;data    android:mimeType=&quot;mydata/png&quot;    android:scheme=&quot;mydata&quot; /&gt;\n\n这里是既设置了Data又设置了Type，此时调用需要使用\nintent.setDataAndType(Uri.parse(&quot;mydata:&quot;+123456), &quot;mydata/png&quot;);\n\n传递过来之后，使用getIntent()获取意图对象\n并使用intent.getData()获取通过scheme传递过来的数据\nIntent intent = getIntent();String data = intent.getintent.getData().toString();\n\n传递数据除了可以使用scheme传递小型数据外，大型的数据可以使用putExtra(&lt;K&gt;,&lt;V&gt;)的方式来传递键值对\nintent.putExtra(&quot;name&quot;, name);intent.putExtra(&quot;height&quot;, height);\n\n传送过去之后，可以使用gei&lt;String&gt;Extra来获得数据，String可以根据需求来指定\nString name = intent.getStringExtra(&quot;name&quot;);Float height = intent.getFloatExtra(&quot;height&quot;, 0.0f);\n\n显式意图与隐式意图的对比\n\n\n显式意图\n隐式意图\n\n\n\n通过包名、类名指定启动的Activity\n利用意图过滤器(Intent-Filter)来指定对应的Action、Category或**[Data]来启动ActivityAction、Category为必选，Data**为可选，但必须要一一对应\n\n\n一般开启自己的界面使用显式意图\n启动外部应用使用隐式意图\n\n\n显式意图不用设置过滤器，所以可以避免其他应用开启自己。相对安全一些\n自己本身需要设置过滤器，可以被外部应用所引用。\n\n\n启动意图无返回值的启动意图\nstartActivity(intent);\n\n带返回值的启动意图\nstartActivityForResult(intent,requestCode);\n\n想要带返回值，同时也必须传入一个requestCode，用于表示自己的请求码\n返回码ResultCode返回界面时，可以通过改写onBackPressed函数来改变回传结果\n@Overridepublic void onBackPressed() &#123;    Intent intent = new Intent();    intent.putExtra(&quot;main2&quot;, &quot;我是界面2返回的消息&quot;);    setResult(333, intent);    super.onBackPressed();&#125;\n\n如果需要实现一个返回界面的按钮，则需要使用\nfinish();\n\n可以结束当前界面，并返回上一级。作用与返回键相当。\n回传来的界面可以通过改写onActivityResult方法来进行改写\n@Overrideprotected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;    Log.d(TAG, &quot;reqcode:&quot;+requestCode+&quot;--&quot;+&quot;rescode:&quot;+resultCode);    String rststring = data.getStringExtra(&quot;result&quot;);    if(resultCode == Main3Activity.RESULT_CODE_BADSTRING)&#123;        Toast.makeText(this, rststring+&quot;我了个去！&quot;, Toast.LENGTH_LONG).show();    &#125;else &#123;        Toast.makeText(this, rststring, Toast.LENGTH_LONG).show();    &#125;    if(requestCode == REQ_CODE_MIAN2)&#123;        rststring = data.getStringExtra(&quot;main2&quot;);        Toast.makeText(this, &quot;main2返回的消息&quot;+rststring, Toast.LENGTH_LONG).show();    &#125;else if(requestCode == REQ_CODE_MIAN3)&#123;        Toast.makeText(this, &quot;main3返回的消息&quot;+rststring, Toast.LENGTH_LONG).show();    &#125;&#125;\n\n以上这些，做到了在多界面之间切换并且传递数据的功能。\n\n","categories":["实习"],"tags":["Android","实习日记"]},{"title":"实习Day13","url":"/2019/07/17/%E5%AE%9E%E4%B9%A0Day13/","content":"Intent 案例补充——短信收发器\nActivity 的任务堆栈与其生命周期\n\n\n短信发送器案例Activity的四种启动方式默认堆栈模式每一次启动界面都会新生成一个新的Activity\n启动多少起就要返回多少次\n\n\nSingleTop 模式栈顶复用模式\n&lt;activity    android:name=&quot;.Main2Activity&quot;    android:launchMode=&quot;singleTop&quot; /&gt;\n\n\n\n保持栈顶的 Activity 唯一\n\n\n注意，此处只保持栈顶的 Activity 唯一，并不会使栈中的 Activity 唯一\n如果界面存在互相调用的关系，则无法保持 Activity 的唯一性\n \n即：SingleTop 模式可以保证同一 Activity 不会连续出现\nSingleTask 模式栈内复用模式\n&lt;activity    android:name=&quot;.Main2Activity&quot;    android:launchMode=&quot;singleTask&quot; /&gt;\n\n如图：保证了 Activity 只能出现一次，只要在堆栈内出现了这个 Task，就不会构建新的 Activity，每一次调用为退栈\n\n\n即：启动 SingleTask 的 Activity 时，操作为退栈\n\nSingleInstance 模式全局唯一模式（栈外单例模式）\n与 SingleTask 的区别是，这种模式的 Activity 会单独占用一个 Task 栈，具有全局唯一性\n而且没有退栈的操作（因为不用同一个任务栈）\n\n\nActivity 的生命周期\nprivate static final String TAG = &quot;LifeCycle&quot;;@Override//  全局变量适合放在onCreate里面，只运行一次，除非进程被终止protected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    Log.d(TAG, &quot;-----onCreate: &quot;);&#125;@Override//  onRestart、onCreate之后一定跟着onStartprotected void onStart() &#123;    Log.d(TAG, &quot;-----onStart: &quot;);    super.onStart();&#125;@Override//  onStart之后一定跟着onResumeprotected void onResume() &#123;    Log.d(TAG, &quot;-----onResume: &quot;);    super.onResume();&#125;@Override//  onPause时是不可操作界面的protected void onPause() &#123;    Log.d(TAG, &quot;-----onPause: &quot;);    super.onPause();&#125;@Overrideprotected void onStop() &#123;    Log.d(TAG, &quot;-----onStop: &quot;);    super.onStop();&#125;@Overrideprotected void onRestart() &#123;    Log.d(TAG, &quot;-----onRestart: &quot;);    super.onRestart();&#125;@Overrideprotected void onDestroy() &#123;    Log.d(TAG, &quot;-----onDestroy: &quot;);    super.onDestroy();&#125;\n\n\n\n\n\n\nAndroid 主题切换通过修改样式文件，来更改app的显示效果\n\n写法与网页前端的写法一致\n两种继承方式：\n“.”继承“parent”属性继承mediaPlayer音乐播放器的案例\n\n","categories":["实习"],"tags":["Android","实习日记"]},{"title":"实习Day14-15","url":"/2019/07/20/%E5%AE%9E%E4%B9%A0Day14-15/","content":"如何设计框架结构以及MVC模式如何提交代码与更新\n\ngerrit\n\nredmine\n\n\n\n\n模块划分需求依赖接口——依赖文档\n提供对外接口——\n\n类图\n时序图核心功能 (User Case)\n依赖接口\n对外接口\n\n\n","categories":["实习"],"tags":["实习日记"]},{"title":"实习Day16","url":"/2019/07/22/%E5%AE%9E%E4%B9%A0Day16/","content":"**Fragment **使用\n项目环境搭建\n实现功能：\n\n“播放歌曲”界面的UI\n播放列表\n正在播放\n点击列表切换\n上一曲、下一曲\n播放、暂停\n\n\n\nRadioGroup 切换状态时更换图片、字体、颜色等在页面配置文件中使用动态设置：\n&lt;RadioButton             android:textColor=&quot;@color/color_selector&quot; /&gt;\n\n然后在 color_selector.xml 文件中写入标签\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;item android:color=&quot;#00A779&quot; android:state_checked=&quot;true&quot; &gt;&lt;/item&gt;&lt;item android:color=&quot;#FFAF64&quot; android:state_checked=&quot;false&quot; &gt;&lt;/item&gt;&lt;/selector&gt;\n\n此时，在切换的时候可以更改选中时的状态了\n切换图片同理，更改 drawable属性即可\n&lt;RadioButton             android:drawableTop=&quot;@drawable/drawable_selector&quot; /&gt;\n\n\n\n打包同一个样式文件指定一个 style 属性，然后在 style 属性中指定样式即可（继承关系）\nFragment 控件案例继承于 Activity \n将一个 Activity 分割成了多个子 Fragment\n生命周期类似于 Activity 但也有不同的地方\n创建 Fragment\n\n新建完成后会进行 gradle 同步自动生成一些代码，我们可以进行重写\n静态加载！动态加载分四步\n\n通过 getSupportFragmentManager 获取到 FragmentManager对象\n开启事务，将 Fragment 动态加载至容器中\n提交事务\n\n编码规范利用插件，自动检查阿里巴巴Java规范\n\n","categories":["实习"],"tags":["Android","实习日记"]},{"title":"实习Day2","url":"/2019/07/02/%E5%AE%9E%E4%B9%A0Day2/","content":"需求分析 &amp; Android Studio IDE 的配置与安装\n常用控件的使用\n实现一个电话拨号器\n\n\n需求分析\n分析需求要分维度\n\n\n从状态去分析\n 识别输入\n 识别输出\n 识别状态\n\n\n功能性级别\n 用户可操作的\n 后台（系统）操作的\n\n\n用户级别的功能分析 eg：\n Play/Pause\n Replay\n Stop\n\n\n\n\n\n\n需求分析的成果物\n软件需求\nfeaturelist（功能清单）\n  功能需求定义书\n  UI（界面）、UE（体验）定义书\n\n\n硬件需求\n硬件控制式样书\n  电路图\n\n\n\n核心是要学会做产品设计\n配置Android Studio环境Step1：安装IDE下载、安装。\nStep2：配置SDK在SDK Manager中进行设置，注意要统一版本。此处选择Android Pie（API 28）\nStep3：设置gradle由于敏感问题，国内无法自动下载gradle，解决方法有以下三种：\n\n设置代理 \n使用国内镜像站下载 修改项目中的build.gradle文件，如下  buildscript &#123;    repositories &#123;        maven &#123; url &#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27; &#125;        maven&#123; url &#x27;http://maven.aliyun.com/nexus/content/repositories/jcenter&#x27;&#125;    &#125;    dependencies &#123;        classpath &#x27;com.android.tools.build:gradle:2.2.3&#x27;        // NOTE: Do not place your application dependencies here; they belong        // in the individual module build.gradle files    &#125;&#125;allprojects &#123;    repositories &#123;        maven &#123; url &#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27; &#125;        maven&#123; url &#x27;http://maven.aliyun.com/nexus/content/repositories/jcenter&#x27;&#125;    &#125;&#125;\n  即可自动下载。\n利用本地gradle \n\n最佳解决方法为先设置为使用镜像站下载，下载完毕且可以进行同步后更改为使用本地gradle的方式来进行同步。\nStep4：新建AVD虚拟设备打开AVD Manager，新建虚拟设备，自定义设备。然后运行，就能看到虚拟设备。 分辨率越小越省内存。 存在HAXM或VT-x报错，出现这个问题的原因是需要主板开启虚拟设备加速（VT-x），在BIOS设置中开启\nStep5：利用adb进行调试ADB：Android Debug Bridge  \n常用命令：\n\n\n\nadb命令\n含义\n*参数1\n*参数2\n\n\n\nstart-server\n启动连接\n\n\n\n\nkill-server\n断开连接\n\n\n\n\ninstall\n安装apk包\n*.apk\n\n\n\nuninstall\n卸载某程序\n程序包名(com.xxx[公司名].xxx[项目名])\n\n\n\npush\n上传文件\n待推送(push)文件\n目标（设备）路径\n\n\npull\n下载文件\n待取回(pull)文件\n目标（本地）路径\n\n\nshell\n进入设备终端\n\n\n\n\n进入设备终端后的命令（Linux命令）：\n\n\n\nLinux命令\n含义\n参数1\n*参数2\n\n\n\nrm\nremove|删除\n某文件路径\n\n\n\nls\nlist|列表\n\n\n\n\nmv\nmove|移动（重命名）\n原文件\n新文件\n\n\ncd\nchange directory|切换目录\n路径\n\n\n\ncp\ncopy|复制\n源文件\n目标路径\n\n\npm\n包管理\n\n\n\n\n\n\n\npm指令\n\n\n\n\n\n\ninstall\n安装apk包\n*.apk\nP版本(9.0)只允许安装/data/local/tmp/下的apk包\n\n\n\n-r\n\n强制替换原包（升级更新）\n\n\nuninstall\n卸载包\n包名\n\n\n\nlist packages\n列出所有安装包\n\n\n\n\n\n-3\n\n列出所有第三方安装包\n\n\n关于Android Studio IDE\n工欲善其事必先利其器\n\nAndroid Studio IDE是_JetBrain_g公司开发的IDE，该公司所有的IDE操作界面、使用逻辑都很相似，学会一款了后以后其他的IDE也都能快速上手。（比如PyCharm，学生邮箱可享一年正版！） 特点：\n\n  可以汉化，有开源作者在更新汉化包，切换很方便\n  集成很多小工具，如Terminal、GIT等\n  插件众多，如时间统计wakatime、主题设置One Dark、更换操作方式为vim、Emacs等等\n  文件管理非常方便，无论是本地文件还是设备文件，如图：\n  \n\n常用功能：\n\nAPK打包、签名（下方的一个选项） \n关于包名，在MainActivity.java和AndroidManifest.xml中  \nadb命令，在命令行下按↑键可以很方便地调用历史命令，常用于卸载已有软件，做新机测试 示例为安装包和卸载包 \n\n开发电话拨号器Step1：设计UI界面文件结构：\nmanifest其中manifest文件夹下的AndroidManifest.xml是安卓工程的核心配置文件，每个工程必备且唯一。  在图中所示的地方，标出了主要Java代码的位置。\nMainActivity.java核心逻辑代码 onCreate中创建了唯一的主界面activity_main \nres(resource)存放各种资源（图像、音频等）\n├─drawable 图标├─layout 界面├─mipmap 图标└─values 各种参数\n 修改layout 下的activity_main.xml文件，可以设计出下图的界面（编写xml文件，或使用design图形化设计方式）  常用控件：\n\n  布局layout（水平、垂直）\n  按钮button\n  文本text（标签、文本框）\n  多功能部件（WebView、ImageView、VideoView等等）\n  ……\n\n&lt;LinearLayout        android:id=&quot;@+id/linearLayout&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_marginTop=&quot;8dp&quot;        android:orientation=&quot;vertical&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&gt;\n\n垂直布局：\n\n  id\n  宽度：匹配页面宽度（max）\n  高度：包裹内容（min）\n  顶部留白：8像素\n  方向：垂直\n\n实际效果：\n \nStep2：根据UI实现逻辑（逐功能测试）界面设计好了，按下按钮时应callback 在MainActivity类中添加以下方法\npublic void startcall(View view)&#123;        Toast.makeText(this, &quot;Clicked&quot;, Toast.LENGTH_LONG).show();    &#125;\n\n\n并在界面的按钮控件上绑定该函数\n&lt;Button        ...        android:onClick=&quot;startcall&quot;        android:text=&quot;拨号&quot;        ... /&gt;\n\n或者  \n意思是当按键点击时，调用startcall方法\nStep3：测试UI效果设置好了测试一下\n \n Toast弹出了\nstep4：实现拨打电话继续设计逻辑从文本框中提取数字==&gt;数字用于拨号\n1、从文本框中提取出数字设置文本框的id\n  \n寻找我们设置的文本框（类似于设置一个可以访问的socket？  \n利用et_number可以获取文本等字符串操作 取出拨号数字  \n现在字符串phonenum中保存的就是我们需要拨号的号码\n2、用系统自带的电话应用去拨号拨号实现方式：意图Intent  测试一下：发现会闪退  查询logcat，发现问题出在权限上 原来是没有拨号权限  Android 5.0之前的版本可以使用这种方式来申请权限，之后的不可以，故采用动态授权的方式。\n法一：利用Android提供的动态获取权限API *注意：此处包含了版本适配，单就算是旧版也是需要在AndroidManifest.xml中添加权限才能使用的 测试一下：\n  \n注意：这里，第一次点击*deny，是拒绝权限；第二次点allow**，是同意了权限，但是并不会拨出电话。第三次点击拨号，此时有了拨号权限，所以才可以拨出电话。这就很蠢，UE需要优化。 在同级添加一个申请权限结果的反馈，利用toast做输出  测试结果：\n  \n在反馈结果中，如果获得了权限，是可以直接执行意图的，即直接拨号，达到了最佳体验。\n法二：利用开源框架获取权限补充\n如何使用开源框架在build.gradle中添加dependencies：\n如何使用github\n\n","categories":["实习"],"tags":["Android","实习日记"]},{"title":"实习Day3","url":"/2019/07/03/%E5%AE%9E%E4%B9%A0Day3/","content":"\n\n\n","categories":["实习"],"tags":["Android","实习日记"]},{"title":"实习Day4","url":"/2019/07/04/%E5%AE%9E%E4%B9%A0Day4/","content":"Android 开发：测试方法：白盒测试调试方法：Log.d、断点单步调试数据存储方法：\n\nSharedPreferences存储小型数据\n使用文件（内/外）存储\n\n\n\n测试调试方法单元测试针对某一个功能进行测试\n​    C语言——函数\n​    Java——类\n将单元隔离开进行独立测试\n\n有两种测试方式：\n\nAndroidTest——启动Android设备进行测试\ntest——不启动Android设备进行本地测试\n\nstep1.新建Java类\nstep2.对新类创建本地测试包\n@Before和@After为测试前准备和测试后执行\n！注意：只有公有方法才可以进行测试，即public关键字才可以测试，对私有方法private不进行测试。\n生成测试用例\n\nstep3.测试用例的编写\nassertEquals()函数意味判断两值是否相等。\nstep4.进行测试故意写错了mm.multi方法，运行测试，发现测试用例可以自动发现问题。\n\n测试完成。\nstep5.安卓真机测试\n真机测试使用模拟机或实机进行测试。\n速度会比本地测试要慢很多。单元测试使用相对较少\n调试方法日志记录级别从高到低，数量越来越少，重要程度越来越高。\n\n\n\nlog级别\n\n\n\n\nverbose\n所有级别的log\n\n\ninfo\ninfo信息\n\n\ndebug\ndebug级别的信息\n\n\nwarn\n警告\n\n\nerror\n报错\n\n\nlogcat过滤方法\nTAG法\n\n\n\n\n关键字法（略）\n\n终端下logcat命令使用方法\n进入adb shell\n使用logcat抓取日志\n\n\nlogcat -s MainActivity:D \n-s按照TAG抓取日志\nMainActivity为TAG名\n:D为debug级别的日志\n\n利用grep来过滤关键字\n\nlogcat | grep *\n*为待过滤的字符串\n断点调试\n设置断点\n单步执行\n\n\n数据存储结构5种数据存储方式：\n使用SharedPreferences存储数据\n文件存储数据\nSQLite存储数据\n\n1. 使用 SharedPreferences 存储数据设计UI界面\n\nUI设计补充：\nandroid:hint输入框提示文本\nandroid:inputType该文本框格式，textPersonName自动限制单行，textPassword自动隐藏字符\n绑定后台逻辑\n获取输入信息\n判断是否输入\n判断是否正确\n判断是否需要保存用户信息\n\n\nCTRL+Q查询注释\n\npackage com.example.datademo;import android.content.SharedPreferences;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.CheckBox;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123;    private EditText et_username;    private EditText et_password;    private CheckBox cb_saveme;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        //  初始化控件        initView();        //  读取信息        reviceInfo();    &#125;    private void initView() &#123;        /*         * 初始化控件         * */        et_username = findViewById(R.id.et_PersonName);        et_password = findViewById(R.id.et_Password);        cb_saveme = findViewById(R.id.cb_saveMe);    &#125;    private void reviceInfo() &#123;        /*        * 读取信息        * */        SharedPreferences sp = getSharedPreferences(&quot;saveinfo&quot;, MODE_PRIVATE);        String getUsername = sp.getString(&quot;us&quot;, &quot;&quot;);        String getPassword = sp.getString(&quot;pw&quot;, &quot;&quot;);        Boolean getSaveStatus = sp.getBoolean(&quot;ss&quot;, false);        if (getSaveStatus)&#123;            et_username.setText(getUsername);            et_password.setText(getPassword);            cb_saveme.setChecked(getSaveStatus);            Log.d(&quot;Login&quot;, &quot;reviceInfo: Read&quot;);        &#125;else &#123;            et_username.setText(&quot;&quot;);            et_password.setText(&quot;&quot;);            Log.d(&quot;Login&quot;, &quot;reviceInfo: Not Read&quot;);        &#125;    &#125;    public void login_onClick(View view) &#123;//        1.获取输入的用户名和密码        Log.d(&quot;Login&quot;, &quot;login_onClick: &quot;);        String username = et_username.getText().toString().trim();        String password = et_password.getText().toString().trim();//        2.如果没有输入则提示用户输入        if (username.isEmpty()||password.isEmpty())&#123;            showToast(&quot;输入信息不完整！&quot;);            return;        &#125;//        3.判断是否正确，正确则pass，错误则failed        if (username.equals(&quot;valpha&quot;)&amp;&amp;password.equals(&quot;123456&quot;))&#123;            showToast(&quot;登陆信息正确！登陆成功！&quot;);//          检查checkBox是否勾选，如果勾选则保存相应的数据和状态            saveUserInfo(username, password, cb_saveme.isChecked());        &#125; else  &#123;            showToast(&quot;登录信息错误！登陆失败！&quot;);        &#125;    &#125;    private void saveUserInfo(String username, String password, boolean savestatus) &#123;        SharedPreferences sp = getSharedPreferences(&quot;saveinfo&quot;, MODE_PRIVATE);        SharedPreferences.Editor editor = sp.edit();        /*        * 存储路径为/data/data/&lt;包名&gt;/shared_prefs/*.xml        */        editor.putString(&quot;us&quot;, username);        editor.putString(&quot;pw&quot;, password);        editor.putBoolean(&quot;ss&quot;, savestatus);        editor.apply();        Log.d(&quot;Login&quot;, &quot;saveUserInfo:Info has saved!&quot;);    &#125;    private void showToast(String str)&#123;        Toast.makeText(this, str, Toast.LENGTH_SHORT).show();    &#125;&#125;\n\n\n\n获取信息\n\n判断输入\n保存用户信息\n使用类似“字典”的方式存储，即key:value键值对的方式保存到xml文件中\n\n创建一个SharedPreferences对象\n创建一个Editor子对象\neditor写入键值对\n应用（类似写入）\n\n显示Toast 封包\n效果测试\n\n文件表单如上\n！注意：由于是表单式存储，不适合保存密码等重要信息！\n2.使用文件存储\n\n\n内部存储\n外部存储\n\n\n\n文件可以直接创建，无权限问题\n有可能被用户删除、需要申请外部读写权限\n\n\n只能由创建它的APP使用\n公共资源，所有app均可使用\n\n\n卸载app时一同被删除\n除了getExternalFilesDir()目录中的文件会被删除外，其余文件不会被删除\n\n\n使用外部存储需要申请外部读写权限！\n内部存储内部存储可以使用的路径有限，在IDE中敲出getdir可以看到如下的自动补全：\n\n利用文件（FILE）类操作文件，并设置log.d进行调试查看路径：\npublic void onClick1(View view) &#123;\tString TAG = &quot;onClick1&quot;;    File cdir = getCacheDir();    File fdir = getFilesDir();    Log.d(TAG, cdir.getAbsolutePath()+&quot;-----&quot;+fdir.getAbsolutePath());&#125;\n\n\n可以看到，getCacheDir的路径为 /data/user/0/com.example.externalfiles/cache\ngetFilesDir的路径为 /data/user/0/com.example.externalfiles/files\n内部存储使用的为包内存储空间 data/user/0/&lt;包名&gt;/files(cache)\n添加文件读写方式——文件流\npublic void onClick1(View view) &#123;    String TAG = &quot;onClick1&quot;;    File cdir = getCacheDir();    File fdir = getFilesDir();    Log.d(TAG, cdir.getAbsolutePath()+&quot;-----&quot;+fdir.getAbsolutePath());    try &#123;        //  默认输出流保存到包的内部files目录下        FileOutputStream fo = openFileOutput(&quot;aaa.txt&quot;, MODE_PRIVATE);        fo.write(&quot;HelloWorld! for default.&quot;.getBytes());        fo.close();    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;    try &#123;        //  保持到cache目录下的方法        File cfile = new File(getCacheDir(), &quot;bbb.txt&quot;);        FileOutputStream fos = new FileOutputStream(cfile);        fos.write(&quot;Test for cache.&quot;.getBytes());        fos.close();    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;\n\ntry/catch语句可以理解为 尝试打开文件流，并写入“Helloworld!”语句，如果出现异常则报错。\nopenFileOutput函数 &lt;包名&gt;/files 文件夹下，其他文件夹下如 cache 文件夹则需要通用的方法，\n即获取文件指针（文件子类），然后新文件流类，对文件流进行操作。\n注意：如果没有使用 try/catch 语句进行异常捕获会报错，以预防空文件的情况发生。IDE可以自动查错。\n\n此处可以选择第二项，即修改异常捕获，IOException 可以捕捉所有的文件读写类异常。\n测试\n\n\n\n路径设置正确，文件写入正常。将包卸载后，包全部清空，不存在内部存储空间，所有内部存储文件全部删除。\n外部存储外部存储使用 Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES); 来获取外部存储路径\n参数有很多：\n\npublic void onClick2(View view) &#123;    //  external    File path = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES);    File moviesfile = new File(path, &quot;aaa.mp4&quot;);    try &#123;        FileOutputStream fos = new FileOutputStream(moviesfile);        fos.write(&quot;empty...&quot;.getBytes());    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;\n\n测试\n发现文件夹下无文件！\n问题是未获得文件读取权限！\n添加动态获取权限的代码：\n@AfterPermissionGranted(RC_EXTERNAL_READ_WRITE)//\t在获取权限时写入文件流    private void methodRequireExternalPermission(File moviesfile) &#123;        String[] perms = &#123;Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;;        if (EasyPermissions.hasPermissions(this, perms))&#123;            try &#123;                FileOutputStream fos = new FileOutputStream(moviesfile);                fos.write(&quot;empty...&quot;.getBytes());                fos.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        else &#123;            EasyPermissions.requestPermissions(this, &quot;请求获取外部存储权限&quot;,RC_EXTERNAL_READ_WRITE, perms );        &#125;    &#125;    public void onClick2(View view) &#123;        //  external        File path = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES);        File moviesfile = new File(path, &quot;aaa.mp4&quot;);        //\t传入文件指针        methodRequireExternalPermission(moviesfile);    &#125;\n\n第一次执行时，会尝试获取权限，之后即可写入文件\n\n\n和代码预期内容一致！\nContinue…\n","categories":["实习"],"tags":["Android","实习日记"]},{"title":"实习Day5","url":"/2019/07/07/%E5%AE%9E%E4%B9%A0Day5/","content":"工欲善其事，必先利其器。今日学习的是常用的工具。\n实用工具、UML、设计模式、系统框架 ……\n\n\n\n核心指标\n变更通过率（改bug后再次提交的正确率）\n模块化\n技术积累1\n速度\n规范性\n质量\n\n常用工具WorkFlow\n\n\n工具\n功能\n\n\n\nRedmine\n需求管理、任务、BUG、Q&amp;A、WIKI\n\n\ngit\n提交代码、规范（提交至gerrit）\n\n\ngerrit\n由有权限的KOL来提交至公司远程库\n\n\nRedmine管理工作流的\n\ngit不多说，直接看大牛教程\n廖雪峰的Git教程\n常用命令：\n\n\n\ngit指令\n说明\n\n\n\nclone\n从远端克隆一个仓库\n\n\nstatus\n查看当前仓库的状态\n\n\nadd\n添加 untracked 文件为 tracked，加入版本控制\n\n\ncommit\n提交本次更改\n\n\npush\n上传变更\n\n\npull\n从远端获取最新的版本\n\n\nreset\n恢复到某一次版本变更\n\n\nlog\n显示版本变更历史记录\n\n\ndiff、show\n显示当前仓库的改动、显示本次提交的变动\n\n\napply\n应用一个patch包，[patch:代码差异包]\n\n\nrm\n删除一个文件（代码管理，可以利用版本回溯找回）\n\n\ncheckout\n切换分支\n\n\nmerge\n合并分支，一般是把辅分支合并到主分支处\n\n\ncherry-pick\n选择另一条分支的某一个commit给merge\n\n\n​    \nGitLab\n相当于私人Github\n常用方式：\ngit pull–&gt;git add/git commit –&gt; git push\n\n慎用git reset --hard命令！，会强制恢复到某一次提交版本。删除多余的文件，常用于重置存在错误的代码\nJenkins\n系统环境UbuntuLinux下的各种常用操作与软件\n安装方法有三\n\n本地运行\n虚拟机（VMware、Docker）\nWindows inside linux\n\n建议虚拟机直接安装\n换源修改 /etc/apt/sources.list 为下列代码，提升下载速度（阿里云镜像）\ndeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\n修改文件之后要执行\nsudo apt update\n\n然后再下载自己需要的软件\nsudo apt install xxxx\n\n\n\n\n\n\nvimLinux系统下的文本编辑器\n菜鸟教程的快捷键\n上神图\napktool逆向解包\n反编译工具。\n但是目前的apk都具有混淆器，使得逆向工程变得很困难。\nsudo apt updatesudo apt install apktool\n\n直接安装，建议换源后再下载安装，速度快。\ndex2jar需要下载可执行包，去https://sourceforge.net/projects/dex2jar/\n下载后放入Ubuntu中执行\n常用的命令为\nsh d2j-dex2jar.sh\n\n","categories":["实习"],"tags":["Android","实习日记"]},{"title":"实习Day6","url":"/2019/07/08/%E5%AE%9E%E4%B9%A0Day6/","content":"Android开发：\n利用SQLite存储数据\n\n\nSQLite存储数据在设备终端使用SQL语句创建和访问数据库数据库结构主键、其余键值、键值类型……\n数据库操作——增删改查\n\n\n操作\n指令\n\n\n\n\ninsert\n增加\n\n\n\ndelete\n删除\n\n\n\nupdate\n修改\n\n\n\nquery (select)\n查找\n\n\n\n​    \n使用 adb shell 进入设备终端，并新建数据库文件touch studentinfo.db\n\n打开数据库，并执行SQL命令squlite3 studentinfo.db\ncreate table student(id integer primary key, name text, stnumber integer);create table student(id integer primary key, name text, stnumber integer);\n\n创建—表单—[学生名]—([name] [数据类型] [主键], [name] [数据类型], ….)\n\n退出SQL\ninsertinsert into student (name, stnumber) values(&#x27;zhangsan&#x27;, 10101);insert into student (name, stnumber) values(&#x27;lisi&#x27;, 12345);insert into student (name, stnumber) values(&#x27;zhangsan&#x27;, 10102);insert into student (name, stnumber) values(&#x27;zhangsan&#x27;, 10103);\n\n\nselect (query)select * from student;select stnumber, name from student where stnumber&gt;10102;\n\n\ndeletedelete from student where stnumber &gt; 10102;\n\n\nupdateupdate student set name=&#x27;lisi&#x27; where stnumber&gt;=10102;\n\n\n\n简单数据库的实现Android源码中创建和使用数据库创建契约类用来保存要操作的表字段内容等\npackage com.example.sqlitedemo;import android.provider.BaseColumns;public class StudentinfoContract &#123;    //  固定写法，对应好对应数据库的table和table对应的字段名    public static class StudentEntry implements BaseColumns &#123;        //  继承自BaseColumns，可以自动实现主键，所以不需要再次创建主键(._ID)        public static String TABLE_NAME = &quot;student&quot;;        public static String COLUMN_NAME_NAME = &quot;name&quot;;        public static String COLUMN_NAME_STNUMBER = &quot;stnumber&quot;;    &#125;&#125;\n\n\n\n\n编写SQLDBOpenHelper类利用Helper来进行数据库的操作，自定义了新建数据库和更新数据库两种方法。\npackage com.example.sqlitedemo;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;import android.util.Log;public class StudentinfoDbHelper extends SQLiteOpenHelper &#123;    //定义一些常量    //  数据库名    private static final String DATABASE_NAME = &quot;studentinfo.db&quot;;    //  数据库版本    private static final int DATABASE_VERSION = 1;    //  创建表的SQL指令代码：create table student(id integer primary key, name text, stnumber integer);    private static final String CREATE_STUDENT_TABLESQL = &quot;create table &quot;            + StudentinfoContract.StudentEntry.TABLE_NAME +&quot; (&quot;            + StudentinfoContract.StudentEntry._ID +&quot; integer primary key, &quot;            + StudentinfoContract.StudentEntry.COLUMN_NAME_NAME +&quot; text, &quot;            + StudentinfoContract.StudentEntry.COLUMN_NAME_STNUMBER +&quot; integer);&quot;;    //  删除表的SQL指令代码：drop table student;    private static final String DROP_STUDENT_TABLESQL = &quot;drop table&quot;            + StudentinfoContract.StudentEntry.TABLE_NAME + &quot;;&quot;;    //  TAG标签    private static final String TAG = &quot;DBHelper&quot;;    //创建DBHelper    public StudentinfoDbHelper(Context context) &#123;        super(context, DATABASE_NAME, null, DATABASE_VERSION);        Log.d(TAG, &quot;StudentinfoDbHelper: Entry DBHelper&quot;);    &#125;    //创建数据库的SQL语句！    //只在找不到数据库时才执行onCreate    @Override    public void onCreate(SQLiteDatabase db)&#123;        Log.d(TAG, &quot;onCreate: &quot;+CREATE_STUDENT_TABLESQL);        db.execSQL(CREATE_STUDENT_TABLESQL);    &#125;    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)&#123;        Log.d(TAG, &quot;onUpgrade: &quot;+ DROP_STUDENT_TABLESQL);        db.execSQL(DROP_STUDENT_TABLESQL);    &#125;&#125;\n\n\n\n\n在主Activity中调用数据库public class MainActivity extends AppCompatActivity &#123;    private StudentinfoDbHelper m_dbHelper;    private SQLiteDatabase db;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        //  创建一个DBHelper对象        m_dbHelper = new StudentinfoDbHelper(this);        //  使用DBHelper对象打开数据库        db = m_dbHelper.getWritableDatabase();        //  关闭数据库        db.close();    &#125;&#125;\n\n\n\n测试使用表单\n\n可以看到自动创建了新的表，而且文件目录下也多了databases的文件夹\n封装类(Utils)将常用的 增删查补方法封装到一个java类中，取名为 *-utils.java\n将学生信息打包成类新建一个class文件\nclass Student &#123;    private int _id;    private String name;    private int stunumber;&#125;\n\n使用代码生成功能，自动生成构造函数以及getter和setter\n\n利用封装类来进行SQL操作Utils类初始化s=&gt;start: 程序初始化op1=&gt;operation: 选择工具类的上下文（调用DBHelper）e=&gt;end: 进入程序界面，等到操作指令s-&gt;op1-&gt;e\n\n想要调用工具类，需要先指定上下文，这里在MainActivity程序初始化的时候进行调用函数\n\nprivate static Context m_ctx = null;private static StudentinfoDbHelper m_dbHelper = null;//  设置上下文，并创建一个DBHelper对象，已创建过的则不必重新创建public static void setContext(Context ctx)&#123;    m_ctx = ctx;    if (m_dbHelper==null)&#123;        m_dbHelper = new StudentinfoDbHelper(m_ctx);    &#125;&#125;\n\n\n\n\n在工具类中写入方法（以插入新数据为例）s=&gt;start: 触发函数e=&gt;end: 程序结束op1=&gt;operation: 执行相对应的 DBHelper 指令s-&gt;op1-&gt;e\n\n\n//  按照学生姓名和学号添加至数据库    public static void insertStudent(Student stu)&#123;        //  判断DBHelper是否存在，不存在则报错        assert(m_dbHelper != null);        //  使用SQLiteDatabase类型来进行写入操作        //  在StudentinfoDbHelper中我们重新定义过onCreate和update方法        //  所以执行.getWritableDatabase()命令时会自动执行我们的onCreate()方法，按照我们的要求去新建数据库        SQLiteDatabase db = m_dbHelper.getWritableDatabase();        //添加数据库        //  需要指定一个ContentValues类型，用values.put()来写入数据        ContentValues values = new ContentValues();        values.put(StudentinfoContract.StudentEntry.COLUMN_NAME_NAME, stu.getName());        values.put(StudentinfoContract.StudentEntry.COLUMN_NAME_STNUMBER, stu.getStunumber());        //  写入数据库        db.insert(StudentinfoContract.StudentEntry.TABLE_NAME,                null, values);        db.close();    &#125;\n\n\n\n\n在主程序中调用工具类的方法public void insertStudent(View view) &#123;    String name  = et_name.getText().toString().trim();    String stunum = et_stunumber.getText().toString().trim();    Student stu = new Student(0, name, Integer.valueOf(stunum));    StudentinfoDbUtils.insertStudent(stu);&#125;\n\n\n\n\n\n工具类实现删除和更新（修改）//  按照学号删除学生    public static int deleteStudent(int stunum)&#123;        assert (m_dbHelper!=null);        SQLiteDatabase db = m_dbHelper.getWritableDatabase();        //where 语句的条件        String whereClause = StudentinfoContract.StudentEntry.COLUMN_NAME_STNUMBER+&quot; = ?&quot;;        //where 语句的值        String[] whereArgs = new String[] &#123;String.valueOf(stunum)&#125;;        //  返回值为删除的数量        int deletecount = db.delete(StudentinfoContract.StudentEntry.TABLE_NAME,                whereClause, whereArgs);        db.close();        return deletecount;    &#125;    //  根据学号更新姓名    public static int updateStudent(int stunum, String newname)&#123;        assert(m_dbHelper != null);        SQLiteDatabase db = m_dbHelper.getWritableDatabase();        //  待更新的条目        ContentValues values = new ContentValues();        values.put(StudentinfoContract.StudentEntry.COLUMN_NAME_NAME, newname);        //  哪些是需要更新的条目        String whereClause = StudentinfoContract.StudentEntry.COLUMN_NAME_STNUMBER+&quot; = ?&quot;;        String[] whereArgs = new String[]&#123;String.valueOf(stunum)&#125;;        int updatecount = db.update(StudentinfoContract.StudentEntry.TABLE_NAME,                values, whereClause, whereArgs);        db.close();        return updatecount;    &#125;\n\n\n\n\n\n\n\npublic void deleteStudent(View view) &#123;        String name  = et_name.getText().toString().trim();        int count = StudentinfoDbUtils.deleteStudent(name);        if (count &lt;= 0)&#123;            Toast.makeText(this, &quot;没有您要删除学生&quot;, Toast.LENGTH_LONG).show();        &#125;else &#123;            Toast.makeText(this, &quot;成功删除了&quot;+count+&quot;条学生信息&quot;, Toast.LENGTH_LONG).show();        &#125;    &#125;    public void updateStudent(View view) &#123;        String name  = et_name.getText().toString().trim();        String stunum = et_stunumber.getText().toString().trim();        int count = StudentinfoDbUtils.updateStudent(Integer.valueOf(stunum), name);        if (count &lt;= 0)&#123;            Toast.makeText(this, &quot;没有您要更新学生&quot;, Toast.LENGTH_LONG).show();        &#125;else &#123;            Toast.makeText(this, &quot;成功更新了&quot;+count+&quot;条学生信息&quot;, Toast.LENGTH_LONG).show();        &#125;    &#125;\n\n\n\n查找方法的实现面对对象编程的特点，是将一切对象作为编程的重点，这里我们把学生作为了对象，那么它应该自己具有自己的属性（值），返回的也是学生，即返回的是由学生组成的列表。\n//  按照学号查找public static List&lt;Student&gt; queryStudent(int stunum)&#123;    assert(m_dbHelper != null);    SQLiteDatabase db = m_dbHelper.getWritableDatabase();    String TAG = &quot;query&quot;;    String[] columns = new String[]&#123;            StudentinfoContract.StudentEntry.COLUMN_NAME_NAME,      //  第0列            StudentinfoContract.StudentEntry.COLUMN_NAME_STNUMBER,  //  第1列            StudentinfoContract.StudentEntry._ID    &#125;;    //  按照学号匹配进行查询的条件阐述    String selection = StudentinfoContract.StudentEntry.COLUMN_NAME_STNUMBER+&quot; = ?&quot;;    String[] selectionArgs = new String[]&#123;String.valueOf(stunum)&#125;;    Cursor cursor = db.query(StudentinfoContract.StudentEntry.TABLE_NAME,            columns,        //  如果给null，则查询所有类            selection,      //  如果射程null，则查询所有信息            selectionArgs,            null,            null,            null);    //  创建一个以学生为元素的列表    ArrayList&lt;Student&gt; stulist = new ArrayList&lt;Student&gt;();    //  利用查询到的指针来访问数据    if (cursor != null &amp;&amp; cursor.getCount() &gt; 0)&#123;        //  使用cursor遍历        while(cursor.moveToNext())&#123;            //  使用游标查询字段，并取出使用            //  创建一个学生列表            //  与columns查询列的下标一致            String tmpname = cursor.getString(0);            int tmpstunum = cursor.getInt(1);            int id = cursor.getInt(2);            //  官方写法，易读性高            //cursor.getString(cursor.getColumnIndex(StudentinfoContract.StudentEntry.COLUMN_NAME_NAME));            //  创建一个学生对象，用来存储获取的数据            Student student = new Student(id, tmpname, tmpstunum);            //  将获取的学生数据存储到待返回的列表中            stulist.add(student);            Log.d(TAG, tmpname+&quot;---&quot;+tmpstunum+&quot;---&quot;+id);        &#125;    &#125;    //\t关闭数据库    db.close();    return stulist;&#125;\n\n\n\n\n\n\n\npublic void queryStudent(View view) &#123;    String stunum = et_stunumber.getText().toString().trim();    //从数据库中查询出来了学生对象的列表    List&lt;Student&gt; list = StudentinfoDbUtils.queryStudent(Integer.valueOf(stunum));    //\t遍历list,打印学生信息    //\tJava语言的循环写法    //\tfor(Student stu: list)&#123;    //\t\tLog.d(TAG, stu.get_id()+&quot;---&quot;+stu.getName()+&quot;---&quot;+stu.getStunumber());    //\t&#125;    //\tC语言的写法    for (int i=0 ; i&lt;list.size(); i++)&#123;        Student stu = list.get(i);        Log.d(TAG, stu.get_id()+&quot;---&quot;+stu.getName()+&quot;---&quot;+stu.getStunumber());    &#125;&#125;\n\n\n\n效果测试四个按钮的功能在Utils类里有说明：\n其中删除按钮对应的是第二个——按照姓名删除学生\n\n\n左侧显示的为当前表中的所有记录\n下方为logcat，用于显示查询query的查询信息。\n事务的概念和实验数据库事务的概念\n1、为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。\n\n数据库事务的特性具有以下四个属性ACID\n\n原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。\n\n实例//\t开启事务传送db.beginTransaction();try&#123;    db.insert();    db.xxxxx;    ......;    //\t设置事务成功标记    db.setTransactionSuccessful();&#125; finally&#123;//\t结束事务db.endTransaction()   &#125;//\t只有关闭数据库才会将缓存写入数据库db.close();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["实习"],"tags":["Android","实习日记"]},{"title":"实习Day7","url":"/2019/07/09/%E5%AE%9E%E4%B9%A0Day7/","content":"ListView控件的使用\n\n\nListView的使用关于Adapter由于列表可以显示各种各样的内容，Android适配使用Adapter来设置不同的显示样式\n\n\n\n\n\n\n\nArrayAdapter的调用ArrayAdapter为最简单的单列表\nUI界面测试\n\n点击逻辑\n\npublic class MainActivity extends AppCompatActivity &#123;    private ListView lv;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        lv = (ListView)findViewById(R.id.lv_);        final Object[] objects = new String[]&#123;                &quot;111&quot;,&quot;222&quot;,&quot;333&quot;,&quot;444&quot;,&quot;555&quot;,&quot;666&quot;,&quot;777&quot;,                &quot;111&quot;,&quot;222&quot;,&quot;333&quot;,&quot;444&quot;,&quot;555&quot;,&quot;666&quot;,&quot;777&quot;        &#125;;        ArrayAdapter&lt;Object&gt; adapter = new ArrayAdapter&lt;&gt;(this,                //  代表每个item的样式                android.R.layout.simple_list_item_1,                //  表示每个item显示的内容                objects);        lv.setAdapter(adapter);        lv.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;            private String TAG = &quot;ListView&quot;;            @Override            public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;                Log.d(TAG, &quot;onItemClick: &quot;+objects[position]);            &#125;        &#125;);    &#125;&#125;\n\n\n\n由logcat的调试信息可以看到，返回的值为索引列表，利用索引（下标）来访问数据。\n\nSimpleAdapter的使用设置Adapter五个参数：\n\n上下文——this\n\n数据本体——data\n\n布局——R.layout.item1\n\n数据来源的字段——from\n\n对应的控件——to\n\n```javalv = (ListView)findViewById(R.id.lv_);final List&lt;Map&lt;String, String&gt;&gt; data = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 10; i++){\nMap&lt;String, String&gt; map = new HashMap&lt;&gt;();\nmap.put(&quot;Name&quot;, &quot;zhangsan&quot;+i);\nmap.put(&quot;PhoneNumber&quot;, &quot;1001000100&quot;+i);\ndata.add(map);\n\n}String[] from = new String[]{“Name”, “PhoneNumber”};int[] to = new int[] {R.id.tv_name, R.id.tv_phonenumber};SimpleAdapter adapter = new SimpleAdapter(this,\n    //  数据本体\n    data,\n    //  布局\n    R.layout.item1,\n    //  数据的字段\n    from,\n    //  数据对应的位置\n    to);\n\nlv.setAdapter(adapter);\n    ![SimpleAdapter的设置](http://blog-image.pek3b.qingstor.com/201907091504_873.png)##### 设置布局```xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;TextView        android:id=&quot;@+id/tv_name&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_weight=&quot;1&quot;        android:gravity=&quot;right&quot;        android:layout_margin=&quot;5dp&quot;        android:textSize=&quot;40sp&quot;        android:text=&quot;张三&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/tv_phonenumber&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_weight=&quot;3&quot;        android:layout_margin=&quot;5dp&quot;        android:textSize=&quot;40sp&quot;        android:fontFamily=&quot;sans-serif-light&quot;        android:text=&quot;10010001000&quot; /&gt;&lt;/LinearLayout&gt;\n\n\n效果测试\nBaseAdapter创建一个自己的Adapter（继承自BaseAdapter）\nALT+Insert 生成代码\n\n自动生成代码\n\n查询是否由可用的View\nCTRL+ALT+F 将局部变量转为全局变量\n\nAndroid 内存回收机制将可用的内存空间（View）腾空出来，并回收利用View\n\nprivate class MyAdapter extends BaseAdapter&#123;    private String TAG = &quot;MyAdapter&quot;;    @Override    public int getCount() &#123;        return 100;    &#125;    @Override    public Object getItem(int position) &#123;        return null;    &#125;    @Override    public long getItemId(int position) &#123;        return 0;    &#125;    @Override    public View getView(int position, View convertView, ViewGroup parent) &#123;        //传入三个参数，关注前两个        //  第一个为位置索引        //  第二个为“回收站”，可以判断是否利用可以回收利用的View，节约内存需要使用        TextView view;        Log.d(TAG, &quot;getView: &quot;+position);        //  第三步：做好内存回收机制        if (convertView == null)&#123;            Log.d(TAG, &quot;getView: 使用船新的View！！&quot;);            view = new TextView(MainActivity.this);        &#125; else&#123;            Log.d(TAG, &quot;getView: 回收利用View！&quot;);            view = (TextView) convertView;        &#125;        //  第四步：设置Item的属性（加载数据）        view.setText(&quot;MyItem&quot;+position);        view.setTextSize(30);        //  第五步：返回View对象        return view;    &#125;&#125;\n\n\n\n加载item数据，返回View对象\n效果测试背后的logcat显示了是否申请了新的View\n\nInflater定制ListView的Item绘制子布局View.inflate()方法可以给对象注入一个布局\n因此，我们首先需要一个“子布局”来用于 inflate 到 ListView 控件中\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot; &gt;    &lt;ImageView        android:id=&quot;@+id/iv_icon&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        tools:srcCompat=&quot;@tools:sample/avatars&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tv_title&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_marginStart=&quot;0dp&quot;        android:layout_marginLeft=&quot;0dp&quot;        android:textSize=&quot;25sp&quot;        android:maxLines=&quot;1&quot;        android:layout_toEndOf=&quot;@+id/iv_icon&quot;        android:layout_toRightOf=&quot;@+id/iv_icon&quot;        android:text=&quot;标题标题标题标题标题标题&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tv_subtitle&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_below=&quot;@+id/tv_title&quot;        android:layout_marginStart=&quot;4dp&quot;        android:layout_marginLeft=&quot;4dp&quot;        android:layout_marginTop=&quot;0dp&quot;        android:layout_toEndOf=&quot;@+id/iv_icon&quot;        android:layout_toRightOf=&quot;@+id/iv_icon&quot;        android:maxLines=&quot;3&quot;        android:text=&quot;正文\\n正文\\n正文\\n正文\\n&quot;        android:textSize=&quot;25sp&quot; /&gt;&lt;/RelativeLayout&gt;\n\n\n在 Adapter.getView() 中进行 inflate()public View getView(int position, View convertView, ViewGroup parent) &#123;    //传入三个参数，关注前两个    //  第一个为位置索引    //  第二个为“回收站”，可以判断是否利用可以回收利用的View，节约内存需要使用    convertView = View.inflate(MainActivity.this, R.layout.my_item, null);\treturn convertView;&#125;\n\n这里只由基本的调用逻辑，没进行数据更新和内存回收等优化。\n利用 findViewById() 查找控件，并对标签进行更新\n每次更新都需要重复使用 findViewById() 实属浪费\n所以引入了接下来的内容：\n使用 ViewHolder 进行数据更新在 View 控件进行 inflate() 之后，可以使用\n//\t对新的View类指定新的ViewHolderView.setTag(ViewHolder);//\t取得已指定过的ViewHolderView.getTag(ViewHolder);\n\nsetTag() getTag() 的对象是ViewHolder，所以我们要新建一个内置类 ViewHolder\nprivate class ViewHolder &#123;    public ImageView iv_icon;    public TextView tv_title;    public TextView tv_subtitle;    //\t以下为构建方法，可以在构建时直接指定对象，也可以设置为空，在生成之后在手动指定    public ViewHolder(ImageView iv_icon, TextView tv_title, TextView tv_subtitle) &#123;        this.iv_icon = iv_icon;        this.tv_title = tv_title;        this.tv_subtitle = tv_subtitle;    &#125;&#125;\n\n这里，我们进行一个内存优化：\n//\t如果没有可以回收的 convertView 则使用 setTag(viewHolder)if (convertView == null) &#123;    convertView = View.inflate(MainActivity.this, R.layout.my_item, null);    viewholder = new ViewHolder(            (ImageView) convertView.findViewById(R.id.iv_icon),            (TextView) convertView.findViewById(R.id.tv_title),            (TextView) convertView.findViewById(R.id.tv_subtitle));        /*\t如果ViewHolder类中没有指定构建方法，则使用以下方式     viewholder = new ViewHolder();     viewholder.iv_icon = (ImageView) convertView.findViewById(R.id.iv_icon);     ...     */    convertView.setTag(viewholder);&#125; else &#123;//\t否则使用已经设置过的getTag(viewHolder)    viewholder = (ViewHolder) convertView.getTag();&#125;return convertView;\n\n添加一个更新的方式：\n\nviewholder.iv_icon.setBackgroundResource(R.mipmap.ic_launcher);viewholder.tv_title.setText(&quot;我是第&quot;+position+&quot;号标题！&quot;);viewholder.tv_subtitle.setText(&quot;我是第&quot;+position+&quot;号内容&quot;+&quot;我是第&quot;+position+&quot;号内容&quot;+&quot;我是第&quot;+position+&quot;号内容&quot;+&quot;我是第&quot;+position+&quot;号内容&quot;+&quot;我是第&quot;+position+&quot;号内容&quot;+&quot;我是第&quot;+position+&quot;号内容&quot;);\n\n\n\n使用MyAdapter.notifyDataSetChanged()提示数据有更新\n显示结果\n为 Item 添加点击动作在主程序中为ListView控件添加一个Listener用于监听点击动作\n对于ListView来说，一般选中的是某一个条目(Item) 所以需要添加的是\nlv.setOnItemClickListener(new AdapterView.OnItemClickListener());\n\n这里我使用的是创建一个匿名类的方式来实现监听动作，\nlv.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;    @Override    public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;        Toast.makeText(MainActivity.this, &quot;你点击了第&quot;+position+&quot;条项目！&quot;, Toast.LENGTH_SHORT).show();    &#125;&#125;);\n\n此时点击某一个条目会出现一个Toast来提示你点击了某一条：\n\nGridView设计子布局首先设计一个 griditem.xml 布局文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;ImageView        android:id=&quot;@+id/iv_cover&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;@drawable/ic_launcher_background&quot;/&gt;    &lt;TextView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:id=&quot;@+id/tv_songname&quot;        android:text=&quot;歌曲名&quot;        android:textSize=&quot;30sp&quot;        /&gt;    &lt;TextView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:id=&quot;@+id/tv_singer&quot;        android:text=&quot;歌手&quot;        android:textSize=&quot;20sp&quot;/&gt;&lt;/LinearLayout&gt;\n\n\n\n\n编写Adapterclass MyAdapter extends BaseAdapter &#123;    private String TAG = &quot;MyAdapter&quot;;    private ViewHolder viewholder;    @Override    public int getCount() &#123;        return 100;    &#125;    @Override    public Object getItem(int position) &#123;        return null;    &#125;    @Override    public long getItemId(int position) &#123;        return 0;    &#125;    @Override    public View getView(int position, View convertView, ViewGroup parent) &#123;        //传入三个参数，关注前两个        //  第一个为位置索引        //  第二个为“回收站”，可以判断是否利用可以回收利用的View，节约内存需要使用        if (convertView == null) &#123;            convertView = View.inflate(MainActivity.this, R.layout.griditem, null);            viewholder = new ViewHolder(                    (ImageView) convertView.findViewById(R.id.iv_cover),                    (TextView) convertView.findViewById(R.id.tv_songname),                    (TextView) convertView.findViewById(R.id.tv_singer));            convertView.setTag(viewholder);        &#125; else &#123;            viewholder = (ViewHolder) convertView.getTag();        &#125;        //  对ViewHolder进行更新        viewholder.tv_songname.setText(&quot;给我&quot;+position+&quot;首歌的时间&quot;);        viewholder.tv_singer.setText(&quot;我是第&quot;+position+&quot;号歌手&quot;);        return convertView;    &#125;    private class ViewHolder &#123;        public ImageView iv_cover;        public TextView tv_songname;        public TextView tv_singer;        public ViewHolder(ImageView iv_icon, TextView tv_title, TextView tv_subtitle) &#123;            this.iv_cover = iv_icon;            this.tv_songname = tv_title;            this.tv_singer = tv_subtitle;        &#125;    &#125;&#125;\n\n\n\n\n主程序中设置Adapterpublic class MainActivity extends AppCompatActivity &#123;    private GridView gv;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        gv = findViewById(R.id.gv);        MyAdapter myAdapter = new MyAdapter();        gv.setAdapter(myAdapter);    &#125;&#125;\n\nGridView测试\n\n","categories":["实习"],"tags":["Android","实习日记"]},{"title":"实习Day8","url":"/2019/07/10/%E5%AE%9E%E4%B9%A0Day8/","content":"Android网络编程、Handler、Android线程定义\n\nHTTP协议网络请求GET——&gt;请求获取资源——&gt;得到网页源码（包含响应代码）——&gt;浏览器解析源码生成网页\n常见HTTP响应代码\n\n\n\nCode\n\n含义\n\n\n\n200\nOK\n成功\n\n\n403\nForbidden\n拒绝访问\n\n\n404\nNot Found\n找不到页面\n\n\n502\nBad Gateway\n网关拒绝相应\n\n\n504\nGateway Timeout\n网关超时\n\n\n网页源码\n要学会使用开发者工具去查看网页的源码\nAndroid中的网络请求权限申请访问网络需要申请权限\n在Manifest中写入使用权限\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;\n\n这是低级别的权限申请，只需要在配置清单里说明即可，不需要动态申请\nUI设计\n绑定按键监听初始化控件\nprivate void initView() &#123;        et_webaddr = findViewById(R.id.et_url);        tv_webcode = findViewById(R.id.tv_code);        wv_web = (WebView)findViewById(R.id.wv_web);    &#125;\n\n按键监听\npublic void reqWeb(View view) &#123;        webaddr = et_webaddr.getText().toString().trim();        if (webaddr == null) &#123;            Toast.makeText(this, &quot;请求网址为空！&quot;, Toast.LENGTH_SHORT).show();        &#125; else &#123;            requestweb(webaddr);        &#125;    &#125;\n\n网络请求标准写法使用web_addr字符串生成网络资源定位符 URL对象URL url = new URL(webaddr);\n\n使用url获取网络连接请求对象HttpsURLConnection conn = (HttpsUrlConnection) url.openConnection();HttpURLConnection conn = (HttpUrlConnection) url.openConnection();//\thttp与https协议的类是不同的，需要分别使用\n\n\n\n在Android 9.0中（API 28），系统默认不支持非HTTPS的协议，想要使用不安全的HTTP协议需要在Manifest中设置\n&lt;application\tandroid:usesCleartextTraffic=&quot;true&quot;\t...&lt;/application&gt;\n\n\n\n设置请求方法和请求超时时间等参数conn.seteRequestMethod(&quot;GET&quot;);conn.setReadTimeout(5000);\n\n获得返回状态码int code = conn.getResponseCode();\n\n如果请求成功(code==200)则获取返回的数据从返回的流文件中取出字符串显示到TextView上if (200==code) &#123;    InputStream inputStream = conn.getInputStream();    String webcode = inputStream.toString();    tv_webcode.setText(webcode);&#125;\n\n\n\n\n\n坑一：网络请求需要放到主线程中进行！在Android 4.0 以后，为了不影响主线程运行（前台不会被卡死），所有耗时的动作必须放在主线程中执行。\n解决：创建子线程\nprivate void requestweb(final String webaddr) &#123;    new Thread(new Runnable() &#123;        @Override        public void run() &#123;...&#125;).start();\n\n这里，先新建一个 Thread类，并直接使用.start()方法启动子线程\n在Thread中，创建一个匿名可运行类Runnable()&#123;...&#125;，并重写其run()方法\n以上，可以视为Android中使用线程的方法。\n坑二：字节流太大且分块，不可直接转换成字符串流文件的大小不固定，很有可能大到撑爆内存，流的读写均需要缓存，需要循环读取（或写入）固定长度的字节。\n解决：使用标准写法\ninit=&gt;start: 新建一个1KB的缓冲区op1=&gt;operation: 将输入流的数据取出（最大取1024字节）并存入buffer，返回取出的真实大小con1=&gt;condition: 返回值是否大于0？y1=&gt;operation: 将buffer写入输出流（重新拼接）n1=&gt;end: 停止循环，将baos作为输出流转为字符串init-&gt;op1-&gt;con1con1(yes)-&gt;y1(right)-&gt;op1con1(no,down)-&gt;n1\n\nByteArrayOutputStream baos = new ByteArrayOutputStream(inputS);\n\n使用输出流做缓冲，分批分块地取数据\nbyte[] readbuf = new byte[1024];int len;while ((len = inputStream.read(readbuf, 0, 1024)) &gt; 0) &#123;    baos.write(readbuf);&#125;\n\n\n\n\n\n\n\n坑三：更新UI的操作，需要放到主线程中操作UI界面是用户级的接口，为了防止其他应用后台更改UI，Android规定，只允许在主线程中更新UI界面。\n解决：在主线程中更新UI\n关键：线程间的通信使用 handler，通知主线程更新UI\n重点！利用Handler进行线程通信使用继承创建自己的MyHandler类，继承自Handler\n在这里实现了接收到数据后的动作（更新UI）\nprivate class MyHandler extends Handler&#123;    @Override    public void handleMessage(Message msg) &#123;        String webcode = (String) msg.obj;        switch (msg.what)&#123;            case REQUEST_OK:                tv_webcode.setText(webcode);                wv_web.loadData(webcode,&quot;text/html&quot;, &quot;UTF-8&quot;);                break;            case REQUEST_ERR:                tv_webcode.setText(&quot;解析错误！&quot;);                break;        &#125;        super.handleMessage(msg);    &#125;&#125;\n\n在onCreate时创建 myhandler 类\nprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    initView();    myHandler = new MyHandler();&#125;\n\n消息发送方法：\nMessage msg = myHandler.obtainMessage();msg.obj = webcodes;//\tobj 可以为任意的对象，作为数据存储的容器msg.what = REQ_RESULT_OK;//\twhat 为一整形数，用于标识当前数据myHandler.sendMessage(msg);\n\n关于内存泄漏方法一继承onDestroy方法，添加一项，使myHandler清空，防止内存泄漏\n@Override    protected void onDestroy() &#123;        //为了防止内存泄露，在界面销毁的时候，需要把myHandler未进行完成的事宜全部停止        myHandler.removeCallbacksAndMessages(null);        super.onDestroy();    &#125;\n\n方法二在Java 中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用，静态的内部类不会持有外部类的引用。\n将MyHandler声明为静态变量，并在Handler种添加一个Activity的弱引用\n\n苦尽甘来 ——使用匿名线程来更新UIrunOnUiThread(new Runnable() &#123;    @Override    public void run() &#123;        tv_webcode.setText(webcode);    &#125;&#125;);\n\n最极致的Coding体验。仅仅更新控件使用这个，而需要做出逻辑判断时，使用Handler。\n\n🐘大象无形，大哗希声🐕\n\n网络图片加载器网络下载图片与网络源码没有特别多的区别\n核心区别在于获取的对象不同\n\n使用 ImageView 显示\n使用BitmapFactory将文件或流转为图片\n可以使用缓存机制\n\nBitmapFactory转换为图片使用缓存Utils工具类\npublic static void cacheFile(InputStream in, File pathname, String filename) throws IOException &#123;    File file = new File(pathname, filename);    FileOutputStream fos = new FileOutputStream(file);    byte[] readbuf = new byte[1024];    int len;    while ((len = in.read(readbuf, 0,1024))&gt;0)&#123;        fos.write(readbuf, 0, len);    &#125;    fos.close();return ;&#125;\n\n判断是否存在缓存\nif (cachefile.exists()&amp;&amp;cachefile.length() &gt;0) &#123;    Bitmap bitmap = BitmapFactory.decodeFile(cachefile.getAbsolutePath());    iv_image.setImageBitmap(bitmap);    Log.d(TAG, &quot;loadWebPic: 使用了缓存文件&quot;);&#125; else &#123;    Log.d(TAG, &quot;loadWebPic: 使用了网络下载文件&quot;);    new Thread(new Runnable() &#123;        @Override        public void run() &#123;            try &#123;                URL url = new URL(urltext);                if (url.getProtocol().toLowerCase() == &quot;https&quot;) &#123;                    HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();                    conn.setRequestMethod(&quot;GET&quot;);                    conn.setReadTimeout(5000);                    int code = conn.getResponseCode();                    if (200 == code) &#123;                        InputStream in = conn.getInputStream();                        Log.d(TAG, &quot;loadWebPic: &quot;+filename);                        WebCacheUtils.cacheFile(in, getCacheDir(), filename);                        Log.d(TAG, &quot;loadWebPic: &quot;+filename);                        File cachefile = new File(getCacheDir(), filename);                        bitmap = BitmapFactory.decodeFile(cachefile.getAbsolutePath());                        runOnUiThread(new Runnable() &#123;                            @Override                            public void run() &#123;                                iv_image.setImageBitmap(bitmap);                            &#125;                        &#125;);                    &#125;                &#125; else&#123;                    HttpURLConnection conn = (HttpURLConnection) url.openConnection();                    conn.setRequestMethod(&quot;GET&quot;);                    conn.setReadTimeout(5000);                    int code = conn.getResponseCode();                    if (200 == code) &#123;                        InputStream in = conn.getInputStream();                        Log.d(TAG, &quot;loadWebPic: &quot;+filename);                        WebCacheUtils.cacheFile(in, getCacheDir(), filename);                        Log.d(TAG, &quot;loadWebPic: &quot;+filename);                        File cachefile = new File(getCacheDir(), filename);                        bitmap = BitmapFactory.decodeFile(cachefile.getAbsolutePath());                        runOnUiThread(new Runnable() &#123;                            @Override                            public void run() &#123;                                iv_image.setImageBitmap(bitmap);                            &#125;                        &#125;);                    &#125;                &#125;            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;).start();&#125;\n\n\n\nBASE64编码Base64.encodeToString(urltext.substring(urltext.length()-10).getBytes(), Base64.DEFAULT);\n\n\n\nAsyncTask 进行同步操作\n","categories":["实习"],"tags":["Android","实习日记"]},{"title":"实习Day9","url":"/2019/07/13/%E5%AE%9E%E4%B9%A0Day9/","content":"UML统一建模语言、Git使用、Linux相关\n\n\nLinux文件权限问题\n可得10为二进制数来表示权限：\n\n第1位：d为目录、l为链接\n第2-4位：文件（夹）持有者的 读、写、运行权限\n第5-7位：文件（夹）持有者所在的组的 读、写、运行权限\n第8-10位：文件（夹）任何人的 读、写、运行权限\n\n更改权限chmod +* [文件名]\n其中*表示所添加的权限\n\n-rw——- (600)      只有拥有者有读写权限。-rw-r–r– (644)      只有拥有者有读写权限；而属组用户和其他用户只有读权限。-rwx—— (700)     只有拥有者有读、写、执行权限。-rwxr-xr-x (755)    拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。-rwx–x–x (711)    拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。-rw-rw-rw- (666)   所有用户都有文件读、写权限。-rwxrwxrwx (777)  所有用户都有读、写、执行权限。\n\n内存查看可用内存free -m\n或者cat /proc/meminfo\nAndroid Studio IDEGradlesetting中可以包含各个模块\n\napp：主应用\ncommon：公共库\n……\n\nUML\n用例图 (use case)\n类图\n时序图\n……\n\n用例图（Use Case）\n对象\n参与者\n\n用例\n\n\n关系：\n包含(Include)\n扩展(Extend)\n\n类图（class）\n对象\n类\n接口\n成员\n\n关系各种关系的强弱顺序： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖\n\n泛化（Generalization）是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化弗雷的所有特征和行为。\n实现（Realization）是一种类与接口的关系，表示类是接口所有特征和行为的实现。\n关联（Association）是一种拥有的关系，它使一个类知道另一个类的属性和方法。\n聚合（Aggregation）是整体与部分的关系，且部分可以离开整体而单独存在。\n组合（Composition）是整体与部分的关系，但部分不能离开整体而单独存在。\n依赖（Dependency）是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖。\n\n时序图（sequence）对象\n对象生命线\n\n消息\n同步消息\n异步消息\n注释\n约束\n循环关系\n\n\nMarkdown可以画时序图！\nparticipant 客户端\nparticipant 服务器\nparticipant 通行证中心\nNote over 客户端: 用户输入通行证的账号、密码\n客户端-&gt;通行证中心: 发送账号、密码\nNote over 通行证中心: 验证账号、密码\n通行证中心–&gt;&gt;客户端: 返回token\n客户端-&gt;服务器: 发送token\n服务器-&gt;通行证中心: 验证token\n通行证中心–&gt;&gt;服务器: 验证成功\n服务器–&gt;&gt;客户端: 登陆成功\n\n效果如下，但是无法绘制循环体？\nparticipant 客户端participant 服务器participant 通行证中心Note over 客户端: 用户输入通行证的账号、密码客户端-&gt;通行证中心: 发送账号、密码Note over 通行证中心: 验证账号、密码通行证中心--&gt;&gt;客户端: 返回token客户端-&gt;服务器: 发送token服务器-&gt;通行证中心: 验证token通行证中心--&gt;&gt;服务器: 验证成功服务器--&gt;&gt;客户端: 登陆成功\n\nUML绘图工具\nastah\nvisual paradigm\nvisio 等绘图工具\n\n前两个可以实现逆向工程，从 java 代码中生成类图、时序图✔\n而 visio 等工具是纯粹的画图，无法直接导入数据❌\n推荐使用 visual paradigm, 操作界面现代化，相对好看，缺点是软件比较大，占用资源相对高。\n\n","categories":["实习"],"tags":["实习日记","UML","Linux","git"]},{"title":"算法学习笔记一","url":"/2020/03/08/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/","content":"算法学习笔记（一）序章参考文章：Labuladong的算法小抄\n\n\n入门必读数据结构的存储方式\n数组（Array）\n\n连续性存储，可以随机访问\n通过索引快速找到元素\n相对节约存储空间\n不适合插入、删除操作，较难扩容。时间复杂度O(N)\n\n\n链表（Linked List）\n\n链式存储，不能随机访问\n相对消耗更多存储空间\n适合插入、删除操作，时间复杂度O(1)\n\n\n\n数据结构的基本操作\n线性遍历（for/while迭代）\n\n数组遍历：\nvoid traverse(int[] array) &#123;    for (int i = 0; i &lt; array.length; i++) &#123;        //\tarray[i]...    &#125;&#125;\n链表遍历\nclass ListNode &#123;    int val;    ListNode next;&#125;void traverse(ListNode head) &#123;    for (ListNode p = head; p != null; p = p.next) &#123;        //  p.val...    &#125;&#125;\n\n\n非线性遍历（递归调用）\n\n链表递归\nclass ListNode &#123;    int val;    ListNode next;&#125;void traverse(ListNode head) &#123;    //\thead.val...   \ttraverse(head.next);&#125;\n二叉树的递归遍历\nclass TreeNode &#123;    int val;    TreeNode left, right;&#125;void traverse(TreeNode root) &#123;    //\troot.val...    //\t此处为前序遍历    traverse(root.left);    //\t此处为中序遍历    traverse(root.right);    //\t此处为后序遍历&#125;\n\n\n\n动态规划动态规划的一般形式为求解最值。求解动态规划的核心问题是穷举。\n\n难点：存在【重叠子问题】。\n\n使用【备忘录】or【DP table】来优化穷举过程。\n\n\n难点：具备【最优子结构】\n\n难点：需要更新当前的【状态转移方程】\n\n明确【状态】-&gt; 定义dp数组/函数的含义-&gt; 明确【选择】-&gt; 明确 base case\n\n\n\n斐波那契数列 问题1. 暴力递归int fib(int N) &#123;    if (N == 1 || N == 2) return 1;    return fib(N - 1) + fib(N - 2);&#125;\n\n\n时间复杂度分析：\n\n解决每一个子问题不需要循环，只有一个加法操作f(n-1)+f(n-1)，时间复杂度为O(1)\n一共要解决二叉树结点个子问题，总数为指数，时间复杂度为O(2^n)\n\n总复杂度为O(2^n)，指数型。\n这就是重叠子问题。使用【备忘录】可以解决这个问题\n2. 带备忘录的递归解法int fib(int N) &#123;    if (N &lt; 1) return 0;    // 备忘录全初始化为 0    vector&lt;int&gt; memo(N + 1, 0);    // 初始化最简情况    return helper(memo, N);&#125;int helper(vector&lt;int&gt;&amp; memo, int n) &#123;    // base case     if (n == 1 || n == 2) return 1;    // 已经计算过    if (memo[n] != 0) return memo[n];    memo[n] = helper(memo, n - 1) +                 helper(memo, n - 2);    return memo[n];&#125;\n\n\n","categories":["笔记"],"tags":["算法","Java"]},{"title":"设计模式学习笔记","url":"/2020/02/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/","content":"设计模式——面向对象\n\n\n什么是面向对象编程OOP？什么是面向对象编程语言OOPL？\n面向对象编程（Object Oriented Programming）是一种编程范式或编程风格。它以类（Class）或对象（Object）作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。\n面向对象编程语言（Object Oriented Programming Language）是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。\n\n四大特性分别解决了什么问题？\n封装：封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。Java：使用访问权限控制语法（private、public）实现代码封装功能\n抽象：抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。抽象能够有小弟过滤掉不必要关注的信息。Java：接口类（interface）、抽象类（abstract ）\n继承：继承是用来表示类之间的 is-a 关系，继承最大的一个好处就是代码复用Java：单继承extend\n多态：多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态也是很多设计模式、设计原则、编程技巧的代码实现基础，提高代码的扩展性和复用性。必须要有三个语法机制来支持多态特性。\n抽象：父类对象可以引用子类对象\n\n继承：子类继承父类的属性、方法\n\n重写：子类可以重写（override）父类的方法\n\n\nJava：利用接口类（interface）来实现多态特性\n\n接口vs抽象类的区别？(Java)语法特性抽象类：\n\n不允许被实例化，只能被继承\n可以包含属性和方法，方法可以包含实现也可以不包含实现\n子类继承抽象类，必须实现所有的抽象方法\n\n接口：\n\n接口不能包含属性（也就是成员变量）。\n接口只能声明方法，方法不能包含代码实现。\n类实现接口的时候，必须实现接口中声明的所有方法。\n\n存在意义抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。\n接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。\n应用场景根据is-a还是has-a的关系，以及解决代码复用问题还是其他问题来区分使用抽象类还是接口。\n为什么要基于“接口（interface）”编程？有必要为每个类定义接口吗？","categories":["笔记"],"tags":["设计模式","Java","面向对象"]},{"title":"超Nice软件推荐——PC端","url":"/2019/07/03/%E8%B6%85Nice%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94PC%E7%AB%AF/","content":"随时更新……\n\n\n\n\nTypora——markdown编辑器个人感觉是最好用的windows端markdown编辑器了。\n\n  干净、简洁，专注于写作。\n  粘贴图片自动复制到指定文件夹（我用AutoHotKey实现的自动上传图床，Mac端可以使用IPic自动上传图床）。\n  即时预览，这个功能非常好用！\n\n 官网：Typora官网 下载地址：Windows X64 下载\n\nCmder——Terminal for WindowsWindows下的终端实在是难用，cmd难用，powershell强大但界面不忍直视。Putty也太复古了，Xshell感觉还不错，配合Xftp实现服务器管理还是不错的，但是感觉使用Xshell感觉很怪，不够灵活。。 于是乎，我找到了这个，Cmder彻底解决了我的选择困难症。\n\n  配色多样，界面赏心悦目（颜控党的胜利）\n  界面简洁明了，把终端内容作为主体。\n  可以启动多种终端（cmd、powershell、bash、wslbash，特别是wslbash！使用内置linux开发显得是那么的得心应手！）\n  针对不同终端配置环境变量等。\n  多页面拆分，多标签页。\n\n版本说明：推荐下载cmder.zip ，集成git的完整版，配置方便。或者下载cmder.7z，无git版，需要简单配置一下。  官网：Cmder官网 下载地址：github release\n\nScreenToGIF——录屏软件这个软件非常强大，基本只要是在屏幕上出现过的画面，就都可以录制下来。 主要有以下功能：\n\n  屏幕录制\n  摄像头录制\n  录制白板\n  功能强大的GIF编辑器\n\n满足一切对GIF的需求。（其实也能生成视频，安装附加的解码器即可） 这是一个测试：  编辑器： 生成的gif： 官网：ScreenToGIF官网 下载地址：github release\n\n更新中……\n","categories":["分享"],"tags":["软件分享","更新中","PC端"]},{"title":"学生管理系统的实例","url":"/2019/07/10/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E4%BE%8B/","content":"Android开发的实战——学生信息管理系统\nStudentInfoDemo——Github\n\n\n整体规划\n整理开发要求\n整理关键技术点\n设计UI\n逻辑代码实现\n测试\n\n学生管理系统的要求\n利用数据库实现对 学生 { “姓名”、“学号” } 进行管理\n需要能实现 增加、删除、修改、查询 四个功能\n输入学生 { “姓名”、“学号” } 信息可以添加到数据库\n给出“姓名”或“学号”或“姓名”+“学号”来删除已有的数据信息\n给出“姓名”和“学号”信息，将符合学号的数据的姓名修改为给出的姓名\n查询所有存在的数据信息\n给定筛选条件，按照指定的“姓名”或“学号”或“姓名”+“学号”来查询数据信息\n\n\n\n关键技术点操作接口\n两个输入文本框：{ 姓名、**学号 ** }\n四个按钮：{ 插入、删除、修改、查询 }\n一个输出列表：( {姓名、学号}*n )\n\n“学生”对象结构学生类：{ _ID、姓名、学号 }\n数据库操作\n创建数据库\n新建数据表单\n增加对象\n删除对象（姓名、学号、姓名&amp;学号）\n修改（按学号修改姓名）\n查询（姓名or学号）、（顺序）\n\nAndroid数据库的使用\nDBHelper\nDB契约类\nDBUtils工具类\n\nUI设计主布局\n垂直线性布局\n两个文本框 EditTest\n四个按钮 Button\n查询列表 ListView\n\n\n\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;EditText        android:id=&quot;@+id/et_name&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:ems=&quot;10&quot;        android:hint=&quot;请输入学生姓名&quot;        android:inputType=&quot;textPersonName&quot; /&gt;    &lt;EditText        android:id=&quot;@+id/et_stunumber&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:ems=&quot;10&quot;        android:hint=&quot;请输入学生学号&quot;        android:inputType=&quot;number&quot; /&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:orientation=&quot;horizontal&quot;&gt;        &lt;Button            android:id=&quot;@+id/bt_insert&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;1&quot;            android:onClick=&quot;insertStudent&quot;            android:text=&quot;Insert&quot; /&gt;        &lt;Button            android:id=&quot;@+id/bt_delete&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;1&quot;            android:onClick=&quot;deleteStudent&quot;            android:text=&quot;Delete&quot; /&gt;        &lt;Button            android:id=&quot;@+id/bt_update&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;1&quot;            android:onClick=&quot;updateStudent&quot;            android:text=&quot;Update&quot; /&gt;        &lt;Button            android:id=&quot;@+id/bt_query&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;1&quot;            android:onClick=&quot;queryStudent&quot;            android:text=&quot;Query&quot; /&gt;    &lt;/LinearLayout&gt;    &lt;ListView        android:id=&quot;@+id/lv_student&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;    &lt;/ListView&gt;&lt;/LinearLayout&gt;\n\n\n\nListView子布局\n水平线性布局\n_id\n姓名\n学号\n\n\n\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;TextView        android:id=&quot;@+id/_id&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;5dp&quot;        android:layout_weight=&quot;1&quot;        android:gravity=&quot;right&quot;        android:text=&quot;id&quot;        android:textSize=&quot;25sp&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/name&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;5dp&quot;        android:layout_weight=&quot;2&quot;        android:text=&quot;name&quot;        android:textSize=&quot;25sp&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/stunumber&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;5dp&quot;        android:layout_weight=&quot;3&quot;        android:text=&quot;stunumber&quot;        android:textSize=&quot;25sp&quot; /&gt;&lt;/LinearLayout&gt;\n\n\n\n编码逻辑上电初始化s=&gt;start: 启动程序op1=&gt;operation: 初始化控件op2=&gt;operation: 初始化 DBUtils 工具类e=&gt;end: 监听按键下达指令s-&gt;op1-&gt;op2-&gt;e\n\n数据库相关契约类用于存放约定俗成的常量信息，可以理解为C语言中的宏定义\npublic class StudentInfoContract &#123;    public static class StudentEntry implements BaseColumns &#123;        public static String TABLE_NAME = &quot;student&quot;;        public static String COLUMN_NAME_NAME = &quot;name&quot;;        public static String COLUMN_NAME_STNUMBER = &quot;stnumber&quot;;                //\t数据库名和版本号也可以放在这里面        public static String DATABASE_NAME = &quot;student.db&quot;;        public static int DATABASE_VERSION = 1;    &#125;&#125;\n\n\n\nDBHelper主要修改onCreate函数，用于创建自己的表，同时修改一些必备的方法（构造、更新）\ns=&gt;start: 继承自SQLiteOpenHelperop1=&gt;operation: 完善构造函数op2=&gt;operation: 重写自己的 onCreate() 函数op3=&gt;operation: 重写 onUpgrade() 函数e=&gt;end: 完毕s-&gt;op1-&gt;op2-&gt;op3-&gt;e\n\n\n\n\n\npublic class StduentInfoDBHelper extends SQLiteOpenHelper &#123;    private static final String CREATE_STUDENT_TABLESQL = &quot;create table &quot;                    + StudentInfoContract.StudentEntry.TABLE_NAME +&quot; (&quot;                    + StudentInfoContract.StudentEntry._ID +&quot; integer primary key, &quot;                    + StudentInfoContract.StudentEntry.COLUMN_NAME_NAME +&quot; text, &quot;                    + StudentInfoContract.StudentEntry.COLUMN_NAME_STNUMBER +&quot; integer);&quot;;    private static final String DROP_STUDENT_TABLESQL = &quot;drop table&quot;            + StudentInfoContract.StudentEntry.TABLE_NAME + &quot;;&quot;;    //  构造方法    public StduentInfoDBHelper(Context context) &#123;        super(  context,                StudentInfoContract.StudentEntry.DATABASE_NAME,                null,                StudentInfoContract.StudentEntry.DATABASE_VERSION);    &#125;    @Override    public void onCreate(SQLiteDatabase db) &#123;        db.execSQL(CREATE_STUDENT_TABLESQL);    &#125;    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;        db.execSQL(DROP_STUDENT_TABLESQL);    &#125;&#125;\n\n\n\n\n\nUtils工具类工具类可以理解为一个工具箱，所需要的所有的工具（方法）都继承在了这里面\ns=&gt;start: 开始op1=&gt;operation: 初始化 DBHelper（设置好上下文 context）op2=&gt;operation: 实现自己需要的功能： 增删改查e=&gt;end: 结束s-&gt;op1-&gt;op2-&gt;e\n\n函数总览\n设置上下文private static StduentInfoDBHelper m_dbHelper;private static Context m_ctx;public static void setContext(Context ctx)&#123;    m_ctx = ctx;    if (m_dbHelper==null)&#123;        m_dbHelper = new StduentInfoDBHelper(m_ctx);    &#125;&#125;\n\n\n\n按照姓名和学号添加至数据库//  按照学生姓名和学号添加至数据库public static long insertStudent(Student stu)&#123;    assert(m_dbHelper != null);    SQLiteDatabase db = m_dbHelper.getWritableDatabase();    ContentValues values = new ContentValues();    values.put(StudentInfoContract.StudentEntry.COLUMN_NAME_NAME, stu.getName());    values.put(StudentInfoContract.StudentEntry.COLUMN_NAME_STNUMBER, stu.getStunumber());    long insertcount = db.insert(StudentInfoContract.StudentEntry.TABLE_NAME,null, values);    db.close();    //\t此处返回的是数据库中所有条目的数量    return insertcount;&#125;\n\n\n\n按照姓名删除学生//  按照姓名删除学生public static int deleteStudent(String name)&#123;    assert (m_dbHelper!=null);    SQLiteDatabase db = m_dbHelper.getWritableDatabase();    String whereClause = StudentInfoContract.StudentEntry.COLUMN_NAME_NAME+&quot; = ?&quot;;    String[] whereArgs = new String[] &#123;name&#125;;    int deletecount = db.delete(StudentInfoContract.StudentEntry.TABLE_NAME, whereClause, whereArgs);    db.close();    //\t返回成功删除条目的数量    return deletecount;&#125;\n\n\n\n按照学号删除学生//  按照学号删除学生public static int deleteStudent(int stunum)&#123;    assert (m_dbHelper!=null);    SQLiteDatabase db = m_dbHelper.getWritableDatabase();    String whereClause = StudentInfoContract.StudentEntry.COLUMN_NAME_STNUMBER+&quot; = ?&quot;;    String[] whereArgs = new String[] &#123;String.valueOf(stunum)&#125;;    int deletecount = db.delete(StudentInfoContract.StudentEntry.TABLE_NAME, whereClause, whereArgs);    db.close();    //\t返回成功删除条目的数量    return deletecount;&#125;\n\n\n\n按照姓名&amp;学号删除学生这里涉及到一个双重筛选的条件，只需要对whereClause和whereArgs进行编辑即可\n将我们需要匹配的两个字段名在whereClause中用AND方法连接起来，并在whereArgs中添加需要匹配的字符串数组即可\n\n//  按姓名+学号双匹配方式删除学生public static int deleteStudent(String name, int stunum) &#123;    assert (m_dbHelper != null);    SQLiteDatabase db = m_dbHelper.getWritableDatabase();    String whereClause =            StudentInfoContract.StudentEntry.COLUMN_NAME_NAME + &quot; = ?&quot; + &quot; AND &quot; +            StudentInfoContract.StudentEntry.COLUMN_NAME_STNUMBER +&quot; = ?&quot;;    String[] whereArgs = new String[]&#123;name, String.valueOf(stunum)&#125;;    int deletecount = db.delete(StudentInfoContract.StudentEntry.TABLE_NAME, whereClause, whereArgs);    db.close();    return deletecount;&#125;\n\n\n\n根据学号更新姓名//  根据学号更新姓名public static int updateStudent(int stunum, String newname)&#123;    assert(m_dbHelper != null);    SQLiteDatabase db = m_dbHelper.getWritableDatabase();    ContentValues values = new ContentValues();    values.put(StudentInfoContract.StudentEntry.COLUMN_NAME_NAME, newname);    String whereClause = StudentInfoContract.StudentEntry.COLUMN_NAME_STNUMBER+&quot; = ?&quot;;    String[] whereArgs = new String[]&#123;String.valueOf(stunum)&#125;;    int updatecount = db.update(StudentInfoContract.StudentEntry.TABLE_NAME, values, whereClause, whereArgs);    db.close();    //\t返回成功更新条目的数量    return updatecount;&#125;\n\n\n\n设置查询需要用的字段名因为每次查询都需要使用，所以设置成为全局变量\nprivate static String[] columns = new String[]&#123;        StudentInfoContract.StudentEntry._ID,                   //  第0列        StudentInfoContract.StudentEntry.COLUMN_NAME_NAME,      //  第1列        StudentInfoContract.StudentEntry.COLUMN_NAME_STNUMBER   //  第2列&#125;;\n\n后面使用的所有查询方法都可以直接使用columns的查询变量\n查询所有条目public static List&lt;Student&gt; queryStudent()&#123;    assert (m_dbHelper != null);    SQLiteDatabase db = m_dbHelper.getWritableDatabase();    //\t此处，columns后面紧跟着是要查询的列和判断条件，设置为null为全部查询    Cursor cursor = db.query(StudentInfoContract.StudentEntry.TABLE_NAME,                             columns, null, null, null, null, null);    ArrayList&lt;Student&gt; stulist = new ArrayList&lt;Student&gt;();    if (cursor != null &amp;&amp; cursor.getCount()&gt;0)&#123;        while (cursor.moveToNext())&#123;            String tmpname = cursor.getString(cursor.getColumnIndex(StudentInfoContract.StudentEntry.COLUMN_NAME_NAME));            int tmpstunumber = cursor.getInt(cursor.getColumnIndex(StudentInfoContract.StudentEntry.COLUMN_NAME_STNUMBER));            int tmp_id = cursor.getInt(cursor.getColumnIndex(StudentInfoContract.StudentEntry._ID));            Student tmpstu = new Student(tmp_id,tmpname,tmpstunumber);            stulist.add(tmpstu);        &#125;    &#125;    db.close();    return stulist;&#125;\n\n\n\n按照学号查找public static List&lt;Student&gt; queryStudent(int stunum) &#123;    assert (m_dbHelper != null);    SQLiteDatabase db = m_dbHelper.getWritableDatabase();    String selection = StudentInfoContract.StudentEntry.COLUMN_NAME_STNUMBER + &quot; = ?&quot;;    String[] selectionArgs = new String[]&#123;String.valueOf(stunum)&#125;;    Cursor cursor = db.query(StudentInfoContract.StudentEntry.TABLE_NAME,            columns, selection, selectionArgs, null, null, null);    ArrayList&lt;Student&gt; stulist = new ArrayList&lt;Student&gt;();    if (cursor != null &amp;&amp; cursor.getCount() &gt; 0) &#123;        while (cursor.moveToNext()) &#123;            String tmpname = cursor.getString(cursor.getColumnIndex(StudentInfoContract.StudentEntry.COLUMN_NAME_NAME));            int tmpstunumber = cursor.getInt(cursor.getColumnIndex(StudentInfoContract.StudentEntry.COLUMN_NAME_STNUMBER));            int tmp_id = cursor.getInt(cursor.getColumnIndex(StudentInfoContract.StudentEntry._ID));            Student tmpstu = new Student(tmp_id,tmpname,tmpstunumber);            stulist.add(tmpstu);        &#125;    &#125;    db.close();    return stulist;&#125;\n\n\n\n按照姓名查找//  按照姓名查找条目public static List&lt;Student&gt; queryStudent(String name) &#123;    assert (m_dbHelper != null);    SQLiteDatabase db = m_dbHelper.getWritableDatabase();    String selection = StudentInfoContract.StudentEntry.COLUMN_NAME_NAME + &quot; = ?&quot;;    String[] selectionArgs = new String[]&#123;name&#125;;    Cursor cursor = db.query(StudentInfoContract.StudentEntry.TABLE_NAME,            columns, selection, selectionArgs, null, null, null);    ArrayList&lt;Student&gt; stulist = new ArrayList&lt;Student&gt;();    if (cursor != null &amp;&amp; cursor.getCount() &gt; 0) &#123;        while (cursor.moveToNext()) &#123;            String tmpname = cursor.getString(cursor.getColumnIndex(StudentInfoContract.StudentEntry.COLUMN_NAME_NAME));            int tmpstunumber = cursor.getInt(cursor.getColumnIndex(StudentInfoContract.StudentEntry.COLUMN_NAME_STNUMBER));            int tmp_id = cursor.getInt(cursor.getColumnIndex(StudentInfoContract.StudentEntry._ID));            Student tmpstu = new Student(tmp_id,tmpname,tmpstunumber);            stulist.add(tmpstu);        &#125;    &#125;    db.close();    return stulist;&#125;\n\n\n\n按照姓名&amp;学号查找这里双匹配的方式跟上述删除学生的方法相同\n设置selection和selectionArgs即可\n//  按照姓名&amp;学号双匹配方式查找条目public static List&lt;Student&gt; queryStudent(String name,int stunum) &#123;    assert (m_dbHelper != null);    SQLiteDatabase db = m_dbHelper.getWritableDatabase();    String selection =            StudentInfoContract.StudentEntry.COLUMN_NAME_NAME + &quot; = ?&quot; + &quot; AND &quot; +            StudentInfoContract.StudentEntry.COLUMN_NAME_STNUMBER +&quot; = ?&quot;;    String[] selectionArgs = new String[]&#123;name, String.valueOf(stunum)&#125;;    Cursor cursor = db.query(StudentInfoContract.StudentEntry.TABLE_NAME,            columns, selection, selectionArgs, null, null, null);    ArrayList&lt;Student&gt; stulist = new ArrayList&lt;Student&gt;();    if (cursor != null &amp;&amp; cursor.getCount() &gt; 0) &#123;        while (cursor.moveToNext()) &#123;            String tmpname = cursor.getString(cursor.getColumnIndex(StudentInfoContract.StudentEntry.COLUMN_NAME_NAME));            int tmpstunumber = cursor.getInt(cursor.getColumnIndex(StudentInfoContract.StudentEntry.COLUMN_NAME_STNUMBER));            int tmp_id = cursor.getInt(cursor.getColumnIndex(StudentInfoContract.StudentEntry._ID));            Student tmpstu = new Student(tmp_id,tmpname,tmpstunumber);            stulist.add(tmpstu);        &#125;    &#125;    db.close();    return stulist;&#125;\n\n\n\n主程序s=&gt;start: 开始op1=&gt;operation: 初始化各控件（两个文本框和ListView）op2=&gt;operation: 设置 Utils 的上下文（设置Utils内的DBHelper的上下文）op3=&gt;operation: 为 ListView 编写并设置 Adapter 类op4=&gt;operation: 编写各按键的监听函数e=&gt;end: 结束s-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;e\n\n初始化public class MainActivity extends AppCompatActivity &#123;    private EditText et_name;    private EditText et_stunumber;    private ListView lv_student;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        //\t设置上下文        StudentInfoUtils.setContext(this);        //\t控件初始化        initView();    &#125;    private void initView() &#123;        et_name = (EditText) findViewById(R.id.et_name);        et_stunumber = (EditText) findViewById(R.id.et_stunumber);        lv_student = (ListView) findViewById(R.id.lv_student);        MyAdapter adapter = new MyAdapter();        lv_student.setAdapter(adapter);    &#125;    ...&#125;\n\n\n\n按键响应函数s=&gt;start: 按键按下op1=&gt;operation: 读取 TextView 的数据op2=&gt;subroutine: 利用 Utils 执行对应的操作op3=&gt;operation: 利用 Toast 显示操作结果e=&gt;end: 结束s-&gt;op1-&gt;op2-&gt;op3-&gt;e\n\n增加s=&gt;start: 按键按下op1=&gt;operation: 读取 TextView 的数据con1=&gt;condition: 输入框是否为空?con2=&gt;condition: 返回结果（数据库总条目）是否大于0?op3=&gt;subroutine: 利用 Utils 执行 insert()e1=&gt;end: Toast: 添加成功，返回目前的条目数量e2=&gt;end: Toast: 添加错误，信息不全e3=&gt;end: Toast: 数据库操作错误，添加失败s-&gt;op1-&gt;con1con1(yes)-&gt;op3-&gt;con2con1(no)-&gt;e2con2(yes)-&gt;e1con2(no)-&gt;e3\n\n\n\npublic void insertStudent(View view) &#123;    String name = et_name.getText().toString().trim();    String stunum = et_stunumber.getText().toString().trim();    if (name.length() &gt; 0 &amp;&amp; stunum.length() &gt; 0) &#123;        Student stu = new Student(0, name, Integer.valueOf(stunum));        long count = StudentInfoUtils.insertStudent(stu);        if (count &lt;= 0) &#123;            Toast.makeText(this, &quot;您没有添加学生&quot;, Toast.LENGTH_LONG).show();        &#125; else &#123;            Toast.makeText(this, &quot;信息添加成功！目前一共添加了&quot; + count + &quot;条学生信息&quot;, Toast.LENGTH_LONG).show();        &#125;    &#125; else &#123;        Toast.makeText(this, &quot;信息不全！无法添加学生信息&quot;, Toast.LENGTH_SHORT).show();    &#125;&#125;\n\n\n\n删除s=&gt;start: 按键按下op1=&gt;operation: 读取 TextView 的数据con1=&gt;condition: 两个输入框是否全为空?con2=&gt;condition: 返回删除的数量是否大于0？op2=&gt;operation: 判断执行哪一种删除方法：按姓名删除 or按学号删除 or按照姓名+学号删除op3=&gt;subroutine: 利用 Utils 执行相应的删除方法e1=&gt;end: Toast: 删除成功，提示删除的数量e2=&gt;end: Toast: 信息错误，无法删除e3=&gt;end: Toast: 错误，没有找到匹配的用户s-&gt;op1-&gt;con1con1(no)-&gt;op2-&gt;op3-&gt;con2con1(yes,right)-&gt;e2con2(yes)-&gt;e1con2(no)-&gt;e3con2(111)-&gt;e2\n\n\n\npublic void deleteStudent(View view) &#123;    String name = et_name.getText().toString().trim();    String stunum = et_stunumber.getText().toString().trim();    if (name.length() &lt;= 0 &amp;&amp; stunum.length() &lt;= 0) &#123;        //\t没有输入        Toast.makeText(this, &quot;信息错误！无法删除学生&quot;, Toast.LENGTH_SHORT).show();    &#125;else if (name.length() &gt; 0 &amp;&amp; stunum.length() &lt;= 0)&#123;        //  按姓名删除        int count = StudentInfoUtils.deleteStudent(name);        if (count &lt;= 0) &#123;            Toast.makeText(this, &quot;没有您要删除学生&quot;, Toast.LENGTH_LONG).show();        &#125; else &#123;            Toast.makeText(this, &quot;成功删除了&quot; + count + &quot;条学生信息&quot;, Toast.LENGTH_LONG).show();        &#125;    &#125;else if (name.length() &lt;= 0 &amp;&amp; stunum.length() &gt; 0)&#123;        //  按学号删除        int count = StudentInfoUtils.deleteStudent(Integer.valueOf(stunum));        if (count &lt;= 0) &#123;            Toast.makeText(this, &quot;没有您要删除学生&quot;, Toast.LENGTH_LONG).show();        &#125; else &#123;            Toast.makeText(this, &quot;成功删除了&quot; + count + &quot;条学生信息&quot;, Toast.LENGTH_LONG).show();        &#125;    &#125;else&#123;        //  按姓名+学号删除        int count = StudentInfoUtils.deleteStudent(name, Integer.valueOf(stunum));        if (count &lt;= 0) &#123;            Toast.makeText(this, &quot;没有您要删除学生&quot;, Toast.LENGTH_LONG).show();        &#125; else &#123;            Toast.makeText(this, &quot;成功删除了&quot; + count + &quot;条学生信息&quot;, Toast.LENGTH_LONG).show();        &#125;    &#125;&#125;\n\n\n\n修改（按学号改姓名）s=&gt;start: 按键按下op1=&gt;operation: 读取 TextView 的数据con1=&gt;condition: 学号输入框是否为空?con2=&gt;condition: 返回已更新的数量是否大于0？op3=&gt;subroutine: 利用 Utils 执行相应的更新方法e1=&gt;end: Toast: 更新成功，提示修改的数量e2=&gt;end: Toast: 信息错误，无法更新e3=&gt;end: Toast: 错误，没有找到匹配的用户s-&gt;op1-&gt;con1con1(no)-&gt;op3-&gt;con2con1(yes,right)-&gt;e2con2(yes)-&gt;e1con2(no)-&gt;e3con2(111)-&gt;e2\n\n\n\npublic void updateStudent(View view) &#123;    String name = et_name.getText().toString().trim();    String stunum = et_stunumber.getText().toString().trim();    if (stunum.length() &lt;= 0) &#123;        Toast.makeText(this, &quot;信息错误！无法修改学生&quot;, Toast.LENGTH_SHORT).show();    &#125; else &#123;        int count = StudentInfoUtils.updateStudent(Integer.valueOf(stunum), name);        if (count &lt;= 0) &#123;            Toast.makeText(this, &quot;没有您要更新学生&quot;, Toast.LENGTH_LONG).show();        &#125; else &#123;            Toast.makeText(this, &quot;成功更新了&quot; + count + &quot;条学生信息&quot;, Toast.LENGTH_LONG).show();        &#125;    &#125;&#125;\n\n\n\n查询s=&gt;start: 按键按下op1=&gt;operation: 读取 TextView 的数据con1=&gt;condition: 两个输入框是否全为空?op4=&gt;operation: 用 Utils 查询全部条目con2=&gt;condition: 返回查询的数量是否大于0？op2=&gt;operation: 判断执行哪一种查询方法按姓名查询 or按学号查询 or按照姓名+学号查询op3=&gt;subroutine: 利用 Utils 执行相应的查询方法：e1=&gt;operation: Toast: 查询成功，提示查询到的的数量e2=&gt;operation: Toast: 查询成功，提示查询到的的数量e3=&gt;end: Toast: 错误，没有找到匹配的用户end=&gt;end: 更新 Adapter 中的数据并刷新 TextView 控件s-&gt;op1-&gt;con1con1(no)-&gt;op2-&gt;op3-&gt;con2con1(yes,right)-&gt;op4-&gt;e2con2(yes)-&gt;e1-&gt;endcon2(no)-&gt;e3con2(111)-&gt;e2-&gt;end\n\n\n\npublic void queryStudent(View view) &#123;    String name = et_name.getText().toString().trim();    String stunum = et_stunumber.getText().toString().trim();    if (name.length() &lt;= 0 &amp;&amp; stunum.length() &lt;= 0) &#123;        //  查询所有的学生信息        list = StudentInfoUtils.queryStudent();    &#125;else if (name.length() &gt; 0 &amp;&amp; stunum.length() &lt;= 0)&#123;        //  按姓名查询        list = StudentInfoUtils.queryStudent(name);    &#125;else if (name.length() &lt;= 0 &amp;&amp; stunum.length() &gt; 0)&#123;        //  按学号查询        list = StudentInfoUtils.queryStudent(Integer.valueOf(stunum));    &#125;else&#123;        //  按姓名+学号查询        list = StudentInfoUtils.queryStudent(name,Integer.valueOf(stunum));    &#125;    adapter.notifyDataSetChanged();&#125;\n\n\n\nMyAdapter类s=&gt;start: 继承自BaseAdapterop1=&gt;operation: 改写 getCount() 方法op2=&gt;operation: 改写 getView() 方法op3=&gt;operation: 创建 ViewHolder 类s-&gt;op1-&gt;op2-&gt;op3\n\ngetView()getView()方法是更新控件的关键\ns=&gt;start: getView()op2=&gt;condition: (利用View回收机制)判断是否存在空余的 convertViewy1=&gt;operation: 从已有的 convertView 中 getTag()y2=&gt;operation: 更新 viewHolder 的值e=&gt;end: 返回一个 converViewn1=&gt;operation: 新建一个 viewHoldern2=&gt;operation: 给新建的 viewHolder分配内容n3=&gt;operation: 给 convertView setTag(viewHolder)s-&gt;op2op2(yes)-&gt;y1-&gt;y2-&gt;eop2(no)-&gt;n1-&gt;n2-&gt;n3-&gt;y2\n\n\n\n@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123;    if (convertView == null) &#123;        convertView = View.inflate(MainActivity.this, R.layout.student_item, null);        viewHolder = new ViewHolder();        viewHolder._id = convertView.findViewById(R.id._id);        viewHolder.name = convertView.findViewById(R.id.name);        viewHolder.stunumber = convertView.findViewById(R.id.stunumber);        convertView.setTag(viewHolder);    &#125; else &#123;        viewHolder = (ViewHolder) convertView.getTag();    &#125;    Student stu = list.get(position);    viewHolder._id.setText(String.valueOf(stu.get_id()));    viewHolder.name.setText(stu.getName());    viewHolder.stunumber.setText(String.valueOf(stu.getStunumber()));    return convertView;&#125;\n\n\n\ngetCount()由于是使用list来更新数据，所以此处应该返回一个与list列表长度相同数量的Item\n@Overridepublic int getCount() &#123;    if (list != null) &#123;        return list.size();    &#125; else &#123;        return 0;    &#125;&#125;\n\n\n\n内置ViewHolder类private class ViewHolder &#123;    public TextView _id;    public TextView name;    public TextView stunumber;&#125;\n\n\n\n黑盒测试结果插入\n\n删除\n\n\n\n修改\n\n查询\n\n","categories":["实习"],"tags":["Android"]}]